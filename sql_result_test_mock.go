package libsql

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// SqlResultMock implements sqlResult
type SqlResultMock struct {
	t minimock.Tester

	funcLastInsertId          func() (i1 int64, err error)
	afterLastInsertIdCounter  uint64
	beforeLastInsertIdCounter uint64
	LastInsertIdMock          mSqlResultMockLastInsertId

	funcRowsAffected          func() (i1 int64, err error)
	afterRowsAffectedCounter  uint64
	beforeRowsAffectedCounter uint64
	RowsAffectedMock          mSqlResultMockRowsAffected
}

// NewSqlResultMock returns a mock for sqlResult
func NewSqlResultMock(t minimock.Tester) *SqlResultMock {
	m := &SqlResultMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}
	m.LastInsertIdMock = mSqlResultMockLastInsertId{mock: m}
	m.RowsAffectedMock = mSqlResultMockRowsAffected{mock: m}

	return m
}

type mSqlResultMockLastInsertId struct {
	mock               *SqlResultMock
	defaultExpectation *SqlResultMockLastInsertIdExpectation
	expectations       []*SqlResultMockLastInsertIdExpectation
}

// SqlResultMockLastInsertIdExpectation specifies expectation struct of the sqlResult.LastInsertId
type SqlResultMockLastInsertIdExpectation struct {
	mock *SqlResultMock

	results *SqlResultMockLastInsertIdResults
	Counter uint64
}

// SqlResultMockLastInsertIdResults contains results of the sqlResult.LastInsertId
type SqlResultMockLastInsertIdResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for sqlResult.LastInsertId
func (m *mSqlResultMockLastInsertId) Expect() *mSqlResultMockLastInsertId {
	if m.mock.funcLastInsertId != nil {
		m.mock.t.Fatalf("SqlResultMock.LastInsertId mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlResultMockLastInsertIdExpectation{}
	}

	return m
}

// Return sets up results that will be returned by sqlResult.LastInsertId
func (m *mSqlResultMockLastInsertId) Return(i1 int64, err error) *SqlResultMock {
	if m.mock.funcLastInsertId != nil {
		m.mock.t.Fatalf("SqlResultMock.LastInsertId mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlResultMockLastInsertIdExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &SqlResultMockLastInsertIdResults{i1, err}
	return m.mock
}

//Set uses given function f to mock the sqlResult.LastInsertId method
func (m *mSqlResultMockLastInsertId) Set(f func() (i1 int64, err error)) *SqlResultMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the sqlResult.LastInsertId method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the sqlResult.LastInsertId method")
	}

	m.mock.funcLastInsertId = f
	return m.mock
}

// LastInsertId implements sqlResult
func (m *SqlResultMock) LastInsertId() (i1 int64, err error) {
	mm_atomic.AddUint64(&m.beforeLastInsertIdCounter, 1)
	defer mm_atomic.AddUint64(&m.afterLastInsertIdCounter, 1)

	if m.LastInsertIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.LastInsertIdMock.defaultExpectation.Counter, 1)

		results := m.LastInsertIdMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the SqlResultMock.LastInsertId")
		}
		return (*results).i1, (*results).err
	}
	if m.funcLastInsertId != nil {
		return m.funcLastInsertId()
	}
	m.t.Fatalf("Unexpected call to SqlResultMock.LastInsertId.")
	return
}

// LastInsertIdAfterCounter returns a count of finished SqlResultMock.LastInsertId invocations
func (m *SqlResultMock) LastInsertIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterLastInsertIdCounter)
}

// LastInsertIdBeforeCounter returns a count of SqlResultMock.LastInsertId invocations
func (m *SqlResultMock) LastInsertIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeLastInsertIdCounter)
}

// MinimockLastInsertIdDone returns true if the count of the LastInsertId invocations corresponds
// the number of defined expectations
func (m *SqlResultMock) MinimockLastInsertIdDone() bool {
	for _, e := range m.LastInsertIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LastInsertIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLastInsertIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLastInsertId != nil && mm_atomic.LoadUint64(&m.afterLastInsertIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockLastInsertIdInspect logs each unmet expectation
func (m *SqlResultMock) MinimockLastInsertIdInspect() {
	for _, e := range m.LastInsertIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SqlResultMock.LastInsertId")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LastInsertIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLastInsertIdCounter) < 1 {
		m.t.Error("Expected call to SqlResultMock.LastInsertId")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLastInsertId != nil && mm_atomic.LoadUint64(&m.afterLastInsertIdCounter) < 1 {
		m.t.Error("Expected call to SqlResultMock.LastInsertId")
	}
}

type mSqlResultMockRowsAffected struct {
	mock               *SqlResultMock
	defaultExpectation *SqlResultMockRowsAffectedExpectation
	expectations       []*SqlResultMockRowsAffectedExpectation
}

// SqlResultMockRowsAffectedExpectation specifies expectation struct of the sqlResult.RowsAffected
type SqlResultMockRowsAffectedExpectation struct {
	mock *SqlResultMock

	results *SqlResultMockRowsAffectedResults
	Counter uint64
}

// SqlResultMockRowsAffectedResults contains results of the sqlResult.RowsAffected
type SqlResultMockRowsAffectedResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for sqlResult.RowsAffected
func (m *mSqlResultMockRowsAffected) Expect() *mSqlResultMockRowsAffected {
	if m.mock.funcRowsAffected != nil {
		m.mock.t.Fatalf("SqlResultMock.RowsAffected mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlResultMockRowsAffectedExpectation{}
	}

	return m
}

// Return sets up results that will be returned by sqlResult.RowsAffected
func (m *mSqlResultMockRowsAffected) Return(i1 int64, err error) *SqlResultMock {
	if m.mock.funcRowsAffected != nil {
		m.mock.t.Fatalf("SqlResultMock.RowsAffected mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlResultMockRowsAffectedExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &SqlResultMockRowsAffectedResults{i1, err}
	return m.mock
}

//Set uses given function f to mock the sqlResult.RowsAffected method
func (m *mSqlResultMockRowsAffected) Set(f func() (i1 int64, err error)) *SqlResultMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the sqlResult.RowsAffected method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the sqlResult.RowsAffected method")
	}

	m.mock.funcRowsAffected = f
	return m.mock
}

// RowsAffected implements sqlResult
func (m *SqlResultMock) RowsAffected() (i1 int64, err error) {
	mm_atomic.AddUint64(&m.beforeRowsAffectedCounter, 1)
	defer mm_atomic.AddUint64(&m.afterRowsAffectedCounter, 1)

	if m.RowsAffectedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.RowsAffectedMock.defaultExpectation.Counter, 1)

		results := m.RowsAffectedMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the SqlResultMock.RowsAffected")
		}
		return (*results).i1, (*results).err
	}
	if m.funcRowsAffected != nil {
		return m.funcRowsAffected()
	}
	m.t.Fatalf("Unexpected call to SqlResultMock.RowsAffected.")
	return
}

// RowsAffectedAfterCounter returns a count of finished SqlResultMock.RowsAffected invocations
func (m *SqlResultMock) RowsAffectedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterRowsAffectedCounter)
}

// RowsAffectedBeforeCounter returns a count of SqlResultMock.RowsAffected invocations
func (m *SqlResultMock) RowsAffectedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeRowsAffectedCounter)
}

// MinimockRowsAffectedDone returns true if the count of the RowsAffected invocations corresponds
// the number of defined expectations
func (m *SqlResultMock) MinimockRowsAffectedDone() bool {
	for _, e := range m.RowsAffectedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RowsAffectedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRowsAffectedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRowsAffected != nil && mm_atomic.LoadUint64(&m.afterRowsAffectedCounter) < 1 {
		return false
	}
	return true
}

// MinimockRowsAffectedInspect logs each unmet expectation
func (m *SqlResultMock) MinimockRowsAffectedInspect() {
	for _, e := range m.RowsAffectedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SqlResultMock.RowsAffected")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RowsAffectedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRowsAffectedCounter) < 1 {
		m.t.Error("Expected call to SqlResultMock.RowsAffected")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRowsAffected != nil && mm_atomic.LoadUint64(&m.afterRowsAffectedCounter) < 1 {
		m.t.Error("Expected call to SqlResultMock.RowsAffected")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SqlResultMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockLastInsertIdInspect()

		m.MinimockRowsAffectedInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SqlResultMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SqlResultMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockLastInsertIdDone() &&
		m.MinimockRowsAffectedDone()
}
