package libsql

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SqlResultMock implements sqlResult
type SqlResultMock struct {
	t minimock.Tester

	funcLastInsertId          func() (i1 int64, err error)
	inspectFuncLastInsertId   func()
	afterLastInsertIdCounter  uint64
	beforeLastInsertIdCounter uint64
	LastInsertIdMock          mSqlResultMockLastInsertId

	funcRowsAffected          func() (i1 int64, err error)
	inspectFuncRowsAffected   func()
	afterRowsAffectedCounter  uint64
	beforeRowsAffectedCounter uint64
	RowsAffectedMock          mSqlResultMockRowsAffected
}

// NewSqlResultMock returns a mock for sqlResult
func NewSqlResultMock(t minimock.Tester) *SqlResultMock {
	m := &SqlResultMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.LastInsertIdMock = mSqlResultMockLastInsertId{mock: m}

	m.RowsAffectedMock = mSqlResultMockRowsAffected{mock: m}

	return m
}

type mSqlResultMockLastInsertId struct {
	mock               *SqlResultMock
	defaultExpectation *SqlResultMockLastInsertIdExpectation
	expectations       []*SqlResultMockLastInsertIdExpectation
}

// SqlResultMockLastInsertIdExpectation specifies expectation struct of the sqlResult.LastInsertId
type SqlResultMockLastInsertIdExpectation struct {
	mock *SqlResultMock

	results *SqlResultMockLastInsertIdResults
	Counter uint64
}

// SqlResultMockLastInsertIdResults contains results of the sqlResult.LastInsertId
type SqlResultMockLastInsertIdResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for sqlResult.LastInsertId
func (mmLastInsertId *mSqlResultMockLastInsertId) Expect() *mSqlResultMockLastInsertId {
	if mmLastInsertId.mock.funcLastInsertId != nil {
		mmLastInsertId.mock.t.Fatalf("SqlResultMock.LastInsertId mock is already set by Set")
	}

	if mmLastInsertId.defaultExpectation == nil {
		mmLastInsertId.defaultExpectation = &SqlResultMockLastInsertIdExpectation{}
	}

	return mmLastInsertId
}

// Inspect accepts an inspector function that has same arguments as the sqlResult.LastInsertId
func (mmLastInsertId *mSqlResultMockLastInsertId) Inspect(f func()) *mSqlResultMockLastInsertId {
	if mmLastInsertId.mock.inspectFuncLastInsertId != nil {
		mmLastInsertId.mock.t.Fatalf("Inspect function is already set for SqlResultMock.LastInsertId")
	}

	mmLastInsertId.mock.inspectFuncLastInsertId = f

	return mmLastInsertId
}

// Return sets up results that will be returned by sqlResult.LastInsertId
func (mmLastInsertId *mSqlResultMockLastInsertId) Return(i1 int64, err error) *SqlResultMock {
	if mmLastInsertId.mock.funcLastInsertId != nil {
		mmLastInsertId.mock.t.Fatalf("SqlResultMock.LastInsertId mock is already set by Set")
	}

	if mmLastInsertId.defaultExpectation == nil {
		mmLastInsertId.defaultExpectation = &SqlResultMockLastInsertIdExpectation{mock: mmLastInsertId.mock}
	}
	mmLastInsertId.defaultExpectation.results = &SqlResultMockLastInsertIdResults{i1, err}
	return mmLastInsertId.mock
}

//Set uses given function f to mock the sqlResult.LastInsertId method
func (mmLastInsertId *mSqlResultMockLastInsertId) Set(f func() (i1 int64, err error)) *SqlResultMock {
	if mmLastInsertId.defaultExpectation != nil {
		mmLastInsertId.mock.t.Fatalf("Default expectation is already set for the sqlResult.LastInsertId method")
	}

	if len(mmLastInsertId.expectations) > 0 {
		mmLastInsertId.mock.t.Fatalf("Some expectations are already set for the sqlResult.LastInsertId method")
	}

	mmLastInsertId.mock.funcLastInsertId = f
	return mmLastInsertId.mock
}

// LastInsertId implements sqlResult
func (mmLastInsertId *SqlResultMock) LastInsertId() (i1 int64, err error) {
	mm_atomic.AddUint64(&mmLastInsertId.beforeLastInsertIdCounter, 1)
	defer mm_atomic.AddUint64(&mmLastInsertId.afterLastInsertIdCounter, 1)

	if mmLastInsertId.inspectFuncLastInsertId != nil {
		mmLastInsertId.inspectFuncLastInsertId()
	}

	if mmLastInsertId.LastInsertIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLastInsertId.LastInsertIdMock.defaultExpectation.Counter, 1)

		mm_results := mmLastInsertId.LastInsertIdMock.defaultExpectation.results
		if mm_results == nil {
			mmLastInsertId.t.Fatal("No results are set for the SqlResultMock.LastInsertId")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmLastInsertId.funcLastInsertId != nil {
		return mmLastInsertId.funcLastInsertId()
	}
	mmLastInsertId.t.Fatalf("Unexpected call to SqlResultMock.LastInsertId.")
	return
}

// LastInsertIdAfterCounter returns a count of finished SqlResultMock.LastInsertId invocations
func (mmLastInsertId *SqlResultMock) LastInsertIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLastInsertId.afterLastInsertIdCounter)
}

// LastInsertIdBeforeCounter returns a count of SqlResultMock.LastInsertId invocations
func (mmLastInsertId *SqlResultMock) LastInsertIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLastInsertId.beforeLastInsertIdCounter)
}

// MinimockLastInsertIdDone returns true if the count of the LastInsertId invocations corresponds
// the number of defined expectations
func (m *SqlResultMock) MinimockLastInsertIdDone() bool {
	for _, e := range m.LastInsertIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LastInsertIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLastInsertIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLastInsertId != nil && mm_atomic.LoadUint64(&m.afterLastInsertIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockLastInsertIdInspect logs each unmet expectation
func (m *SqlResultMock) MinimockLastInsertIdInspect() {
	for _, e := range m.LastInsertIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SqlResultMock.LastInsertId")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LastInsertIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLastInsertIdCounter) < 1 {
		m.t.Error("Expected call to SqlResultMock.LastInsertId")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLastInsertId != nil && mm_atomic.LoadUint64(&m.afterLastInsertIdCounter) < 1 {
		m.t.Error("Expected call to SqlResultMock.LastInsertId")
	}
}

type mSqlResultMockRowsAffected struct {
	mock               *SqlResultMock
	defaultExpectation *SqlResultMockRowsAffectedExpectation
	expectations       []*SqlResultMockRowsAffectedExpectation
}

// SqlResultMockRowsAffectedExpectation specifies expectation struct of the sqlResult.RowsAffected
type SqlResultMockRowsAffectedExpectation struct {
	mock *SqlResultMock

	results *SqlResultMockRowsAffectedResults
	Counter uint64
}

// SqlResultMockRowsAffectedResults contains results of the sqlResult.RowsAffected
type SqlResultMockRowsAffectedResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for sqlResult.RowsAffected
func (mmRowsAffected *mSqlResultMockRowsAffected) Expect() *mSqlResultMockRowsAffected {
	if mmRowsAffected.mock.funcRowsAffected != nil {
		mmRowsAffected.mock.t.Fatalf("SqlResultMock.RowsAffected mock is already set by Set")
	}

	if mmRowsAffected.defaultExpectation == nil {
		mmRowsAffected.defaultExpectation = &SqlResultMockRowsAffectedExpectation{}
	}

	return mmRowsAffected
}

// Inspect accepts an inspector function that has same arguments as the sqlResult.RowsAffected
func (mmRowsAffected *mSqlResultMockRowsAffected) Inspect(f func()) *mSqlResultMockRowsAffected {
	if mmRowsAffected.mock.inspectFuncRowsAffected != nil {
		mmRowsAffected.mock.t.Fatalf("Inspect function is already set for SqlResultMock.RowsAffected")
	}

	mmRowsAffected.mock.inspectFuncRowsAffected = f

	return mmRowsAffected
}

// Return sets up results that will be returned by sqlResult.RowsAffected
func (mmRowsAffected *mSqlResultMockRowsAffected) Return(i1 int64, err error) *SqlResultMock {
	if mmRowsAffected.mock.funcRowsAffected != nil {
		mmRowsAffected.mock.t.Fatalf("SqlResultMock.RowsAffected mock is already set by Set")
	}

	if mmRowsAffected.defaultExpectation == nil {
		mmRowsAffected.defaultExpectation = &SqlResultMockRowsAffectedExpectation{mock: mmRowsAffected.mock}
	}
	mmRowsAffected.defaultExpectation.results = &SqlResultMockRowsAffectedResults{i1, err}
	return mmRowsAffected.mock
}

//Set uses given function f to mock the sqlResult.RowsAffected method
func (mmRowsAffected *mSqlResultMockRowsAffected) Set(f func() (i1 int64, err error)) *SqlResultMock {
	if mmRowsAffected.defaultExpectation != nil {
		mmRowsAffected.mock.t.Fatalf("Default expectation is already set for the sqlResult.RowsAffected method")
	}

	if len(mmRowsAffected.expectations) > 0 {
		mmRowsAffected.mock.t.Fatalf("Some expectations are already set for the sqlResult.RowsAffected method")
	}

	mmRowsAffected.mock.funcRowsAffected = f
	return mmRowsAffected.mock
}

// RowsAffected implements sqlResult
func (mmRowsAffected *SqlResultMock) RowsAffected() (i1 int64, err error) {
	mm_atomic.AddUint64(&mmRowsAffected.beforeRowsAffectedCounter, 1)
	defer mm_atomic.AddUint64(&mmRowsAffected.afterRowsAffectedCounter, 1)

	if mmRowsAffected.inspectFuncRowsAffected != nil {
		mmRowsAffected.inspectFuncRowsAffected()
	}

	if mmRowsAffected.RowsAffectedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRowsAffected.RowsAffectedMock.defaultExpectation.Counter, 1)

		mm_results := mmRowsAffected.RowsAffectedMock.defaultExpectation.results
		if mm_results == nil {
			mmRowsAffected.t.Fatal("No results are set for the SqlResultMock.RowsAffected")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmRowsAffected.funcRowsAffected != nil {
		return mmRowsAffected.funcRowsAffected()
	}
	mmRowsAffected.t.Fatalf("Unexpected call to SqlResultMock.RowsAffected.")
	return
}

// RowsAffectedAfterCounter returns a count of finished SqlResultMock.RowsAffected invocations
func (mmRowsAffected *SqlResultMock) RowsAffectedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRowsAffected.afterRowsAffectedCounter)
}

// RowsAffectedBeforeCounter returns a count of SqlResultMock.RowsAffected invocations
func (mmRowsAffected *SqlResultMock) RowsAffectedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRowsAffected.beforeRowsAffectedCounter)
}

// MinimockRowsAffectedDone returns true if the count of the RowsAffected invocations corresponds
// the number of defined expectations
func (m *SqlResultMock) MinimockRowsAffectedDone() bool {
	for _, e := range m.RowsAffectedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RowsAffectedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRowsAffectedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRowsAffected != nil && mm_atomic.LoadUint64(&m.afterRowsAffectedCounter) < 1 {
		return false
	}
	return true
}

// MinimockRowsAffectedInspect logs each unmet expectation
func (m *SqlResultMock) MinimockRowsAffectedInspect() {
	for _, e := range m.RowsAffectedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SqlResultMock.RowsAffected")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RowsAffectedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRowsAffectedCounter) < 1 {
		m.t.Error("Expected call to SqlResultMock.RowsAffected")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRowsAffected != nil && mm_atomic.LoadUint64(&m.afterRowsAffectedCounter) < 1 {
		m.t.Error("Expected call to SqlResultMock.RowsAffected")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SqlResultMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockLastInsertIdInspect()

		m.MinimockRowsAffectedInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SqlResultMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SqlResultMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockLastInsertIdDone() &&
		m.MinimockRowsAffectedDone()
}
