package libsql

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"database/sql"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// TransactionMock implements Transaction
type TransactionMock struct {
	t minimock.Tester

	funcPrepared          func(ctx context.Context, sql string, work func(Statement) error) (err error)
	inspectFuncPrepared   func(ctx context.Context, sql string, work func(Statement) error)
	afterPreparedCounter  uint64
	beforePreparedCounter uint64
	PreparedMock          mTransactionMockPrepared

	funcScan          func(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) (err error)
	inspectFuncScan   func(ctx context.Context, scanner RowScanner, sql string, args ...interface{})
	afterScanCounter  uint64
	beforeScanCounter uint64
	ScanMock          mTransactionMockScan

	funcScanOne          func(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) (err error)
	inspectFuncScanOne   func(ctx context.Context, scanner RowScanner, sql string, args ...interface{})
	afterScanOneCounter  uint64
	beforeScanOneCounter uint64
	ScanOneMock          mTransactionMockScanOne

	funcUpdate          func(ctx context.Context, sql string, args ...interface{}) (r1 sql.Result, err error)
	inspectFuncUpdate   func(ctx context.Context, sql string, args ...interface{})
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mTransactionMockUpdate

	funcUpdateAndGetLastInsertID          func(ctx context.Context, sql string, args ...interface{}) (i1 int64, err error)
	inspectFuncUpdateAndGetLastInsertID   func(ctx context.Context, sql string, args ...interface{})
	afterUpdateAndGetLastInsertIDCounter  uint64
	beforeUpdateAndGetLastInsertIDCounter uint64
	UpdateAndGetLastInsertIDMock          mTransactionMockUpdateAndGetLastInsertID

	funcUpdateAndGetRowsAffected          func(ctx context.Context, sql string, args ...interface{}) (i1 int64, err error)
	inspectFuncUpdateAndGetRowsAffected   func(ctx context.Context, sql string, args ...interface{})
	afterUpdateAndGetRowsAffectedCounter  uint64
	beforeUpdateAndGetRowsAffectedCounter uint64
	UpdateAndGetRowsAffectedMock          mTransactionMockUpdateAndGetRowsAffected
}

// NewTransactionMock returns a mock for Transaction
func NewTransactionMock(t minimock.Tester) *TransactionMock {
	m := &TransactionMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.PreparedMock = mTransactionMockPrepared{mock: m}
	m.PreparedMock.callArgs = []*TransactionMockPreparedParams{}

	m.ScanMock = mTransactionMockScan{mock: m}
	m.ScanMock.callArgs = []*TransactionMockScanParams{}

	m.ScanOneMock = mTransactionMockScanOne{mock: m}
	m.ScanOneMock.callArgs = []*TransactionMockScanOneParams{}

	m.UpdateMock = mTransactionMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*TransactionMockUpdateParams{}

	m.UpdateAndGetLastInsertIDMock = mTransactionMockUpdateAndGetLastInsertID{mock: m}
	m.UpdateAndGetLastInsertIDMock.callArgs = []*TransactionMockUpdateAndGetLastInsertIDParams{}

	m.UpdateAndGetRowsAffectedMock = mTransactionMockUpdateAndGetRowsAffected{mock: m}
	m.UpdateAndGetRowsAffectedMock.callArgs = []*TransactionMockUpdateAndGetRowsAffectedParams{}

	return m
}

type mTransactionMockPrepared struct {
	mock               *TransactionMock
	defaultExpectation *TransactionMockPreparedExpectation
	expectations       []*TransactionMockPreparedExpectation

	callArgs []*TransactionMockPreparedParams
	mutex    sync.RWMutex
}

// TransactionMockPreparedExpectation specifies expectation struct of the Transaction.Prepared
type TransactionMockPreparedExpectation struct {
	mock    *TransactionMock
	params  *TransactionMockPreparedParams
	results *TransactionMockPreparedResults
	Counter uint64
}

// TransactionMockPreparedParams contains parameters of the Transaction.Prepared
type TransactionMockPreparedParams struct {
	ctx  context.Context
	sql  string
	work func(Statement) error
}

// TransactionMockPreparedResults contains results of the Transaction.Prepared
type TransactionMockPreparedResults struct {
	err error
}

// Expect sets up expected params for Transaction.Prepared
func (mmPrepared *mTransactionMockPrepared) Expect(ctx context.Context, sql string, work func(Statement) error) *mTransactionMockPrepared {
	if mmPrepared.mock.funcPrepared != nil {
		mmPrepared.mock.t.Fatalf("TransactionMock.Prepared mock is already set by Set")
	}

	if mmPrepared.defaultExpectation == nil {
		mmPrepared.defaultExpectation = &TransactionMockPreparedExpectation{}
	}

	mmPrepared.defaultExpectation.params = &TransactionMockPreparedParams{ctx, sql, work}
	for _, e := range mmPrepared.expectations {
		if minimock.Equal(e.params, mmPrepared.defaultExpectation.params) {
			mmPrepared.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrepared.defaultExpectation.params)
		}
	}

	return mmPrepared
}

// Inspect accepts an inspector function that has same arguments as the Transaction.Prepared
func (mmPrepared *mTransactionMockPrepared) Inspect(f func(ctx context.Context, sql string, work func(Statement) error)) *mTransactionMockPrepared {
	if mmPrepared.mock.inspectFuncPrepared != nil {
		mmPrepared.mock.t.Fatalf("Inspect function is already set for TransactionMock.Prepared")
	}

	mmPrepared.mock.inspectFuncPrepared = f

	return mmPrepared
}

// Return sets up results that will be returned by Transaction.Prepared
func (mmPrepared *mTransactionMockPrepared) Return(err error) *TransactionMock {
	if mmPrepared.mock.funcPrepared != nil {
		mmPrepared.mock.t.Fatalf("TransactionMock.Prepared mock is already set by Set")
	}

	if mmPrepared.defaultExpectation == nil {
		mmPrepared.defaultExpectation = &TransactionMockPreparedExpectation{mock: mmPrepared.mock}
	}
	mmPrepared.defaultExpectation.results = &TransactionMockPreparedResults{err}
	return mmPrepared.mock
}

//Set uses given function f to mock the Transaction.Prepared method
func (mmPrepared *mTransactionMockPrepared) Set(f func(ctx context.Context, sql string, work func(Statement) error) (err error)) *TransactionMock {
	if mmPrepared.defaultExpectation != nil {
		mmPrepared.mock.t.Fatalf("Default expectation is already set for the Transaction.Prepared method")
	}

	if len(mmPrepared.expectations) > 0 {
		mmPrepared.mock.t.Fatalf("Some expectations are already set for the Transaction.Prepared method")
	}

	mmPrepared.mock.funcPrepared = f
	return mmPrepared.mock
}

// When sets expectation for the Transaction.Prepared which will trigger the result defined by the following
// Then helper
func (mmPrepared *mTransactionMockPrepared) When(ctx context.Context, sql string, work func(Statement) error) *TransactionMockPreparedExpectation {
	if mmPrepared.mock.funcPrepared != nil {
		mmPrepared.mock.t.Fatalf("TransactionMock.Prepared mock is already set by Set")
	}

	expectation := &TransactionMockPreparedExpectation{
		mock:   mmPrepared.mock,
		params: &TransactionMockPreparedParams{ctx, sql, work},
	}
	mmPrepared.expectations = append(mmPrepared.expectations, expectation)
	return expectation
}

// Then sets up Transaction.Prepared return parameters for the expectation previously defined by the When method
func (e *TransactionMockPreparedExpectation) Then(err error) *TransactionMock {
	e.results = &TransactionMockPreparedResults{err}
	return e.mock
}

// Prepared implements Transaction
func (mmPrepared *TransactionMock) Prepared(ctx context.Context, sql string, work func(Statement) error) (err error) {
	mm_atomic.AddUint64(&mmPrepared.beforePreparedCounter, 1)
	defer mm_atomic.AddUint64(&mmPrepared.afterPreparedCounter, 1)

	if mmPrepared.inspectFuncPrepared != nil {
		mmPrepared.inspectFuncPrepared(ctx, sql, work)
	}

	mm_params := &TransactionMockPreparedParams{ctx, sql, work}

	// Record call args
	mmPrepared.PreparedMock.mutex.Lock()
	mmPrepared.PreparedMock.callArgs = append(mmPrepared.PreparedMock.callArgs, mm_params)
	mmPrepared.PreparedMock.mutex.Unlock()

	for _, e := range mmPrepared.PreparedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPrepared.PreparedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrepared.PreparedMock.defaultExpectation.Counter, 1)
		mm_want := mmPrepared.PreparedMock.defaultExpectation.params
		mm_got := TransactionMockPreparedParams{ctx, sql, work}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrepared.t.Errorf("TransactionMock.Prepared got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrepared.PreparedMock.defaultExpectation.results
		if mm_results == nil {
			mmPrepared.t.Fatal("No results are set for the TransactionMock.Prepared")
		}
		return (*mm_results).err
	}
	if mmPrepared.funcPrepared != nil {
		return mmPrepared.funcPrepared(ctx, sql, work)
	}
	mmPrepared.t.Fatalf("Unexpected call to TransactionMock.Prepared. %v %v %v", ctx, sql, work)
	return
}

// PreparedAfterCounter returns a count of finished TransactionMock.Prepared invocations
func (mmPrepared *TransactionMock) PreparedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepared.afterPreparedCounter)
}

// PreparedBeforeCounter returns a count of TransactionMock.Prepared invocations
func (mmPrepared *TransactionMock) PreparedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepared.beforePreparedCounter)
}

// Calls returns a list of arguments used in each call to TransactionMock.Prepared.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrepared *mTransactionMockPrepared) Calls() []*TransactionMockPreparedParams {
	mmPrepared.mutex.RLock()

	argCopy := make([]*TransactionMockPreparedParams, len(mmPrepared.callArgs))
	copy(argCopy, mmPrepared.callArgs)

	mmPrepared.mutex.RUnlock()

	return argCopy
}

// MinimockPreparedDone returns true if the count of the Prepared invocations corresponds
// the number of defined expectations
func (m *TransactionMock) MinimockPreparedDone() bool {
	for _, e := range m.PreparedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PreparedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPreparedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepared != nil && mm_atomic.LoadUint64(&m.afterPreparedCounter) < 1 {
		return false
	}
	return true
}

// MinimockPreparedInspect logs each unmet expectation
func (m *TransactionMock) MinimockPreparedInspect() {
	for _, e := range m.PreparedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionMock.Prepared with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PreparedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPreparedCounter) < 1 {
		if m.PreparedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransactionMock.Prepared")
		} else {
			m.t.Errorf("Expected call to TransactionMock.Prepared with params: %#v", *m.PreparedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepared != nil && mm_atomic.LoadUint64(&m.afterPreparedCounter) < 1 {
		m.t.Error("Expected call to TransactionMock.Prepared")
	}
}

type mTransactionMockScan struct {
	mock               *TransactionMock
	defaultExpectation *TransactionMockScanExpectation
	expectations       []*TransactionMockScanExpectation

	callArgs []*TransactionMockScanParams
	mutex    sync.RWMutex
}

// TransactionMockScanExpectation specifies expectation struct of the Transaction.Scan
type TransactionMockScanExpectation struct {
	mock    *TransactionMock
	params  *TransactionMockScanParams
	results *TransactionMockScanResults
	Counter uint64
}

// TransactionMockScanParams contains parameters of the Transaction.Scan
type TransactionMockScanParams struct {
	ctx     context.Context
	scanner RowScanner
	sql     string
	args    []interface{}
}

// TransactionMockScanResults contains results of the Transaction.Scan
type TransactionMockScanResults struct {
	err error
}

// Expect sets up expected params for Transaction.Scan
func (mmScan *mTransactionMockScan) Expect(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) *mTransactionMockScan {
	if mmScan.mock.funcScan != nil {
		mmScan.mock.t.Fatalf("TransactionMock.Scan mock is already set by Set")
	}

	if mmScan.defaultExpectation == nil {
		mmScan.defaultExpectation = &TransactionMockScanExpectation{}
	}

	mmScan.defaultExpectation.params = &TransactionMockScanParams{ctx, scanner, sql, args}
	for _, e := range mmScan.expectations {
		if minimock.Equal(e.params, mmScan.defaultExpectation.params) {
			mmScan.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScan.defaultExpectation.params)
		}
	}

	return mmScan
}

// Inspect accepts an inspector function that has same arguments as the Transaction.Scan
func (mmScan *mTransactionMockScan) Inspect(f func(ctx context.Context, scanner RowScanner, sql string, args ...interface{})) *mTransactionMockScan {
	if mmScan.mock.inspectFuncScan != nil {
		mmScan.mock.t.Fatalf("Inspect function is already set for TransactionMock.Scan")
	}

	mmScan.mock.inspectFuncScan = f

	return mmScan
}

// Return sets up results that will be returned by Transaction.Scan
func (mmScan *mTransactionMockScan) Return(err error) *TransactionMock {
	if mmScan.mock.funcScan != nil {
		mmScan.mock.t.Fatalf("TransactionMock.Scan mock is already set by Set")
	}

	if mmScan.defaultExpectation == nil {
		mmScan.defaultExpectation = &TransactionMockScanExpectation{mock: mmScan.mock}
	}
	mmScan.defaultExpectation.results = &TransactionMockScanResults{err}
	return mmScan.mock
}

//Set uses given function f to mock the Transaction.Scan method
func (mmScan *mTransactionMockScan) Set(f func(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) (err error)) *TransactionMock {
	if mmScan.defaultExpectation != nil {
		mmScan.mock.t.Fatalf("Default expectation is already set for the Transaction.Scan method")
	}

	if len(mmScan.expectations) > 0 {
		mmScan.mock.t.Fatalf("Some expectations are already set for the Transaction.Scan method")
	}

	mmScan.mock.funcScan = f
	return mmScan.mock
}

// When sets expectation for the Transaction.Scan which will trigger the result defined by the following
// Then helper
func (mmScan *mTransactionMockScan) When(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) *TransactionMockScanExpectation {
	if mmScan.mock.funcScan != nil {
		mmScan.mock.t.Fatalf("TransactionMock.Scan mock is already set by Set")
	}

	expectation := &TransactionMockScanExpectation{
		mock:   mmScan.mock,
		params: &TransactionMockScanParams{ctx, scanner, sql, args},
	}
	mmScan.expectations = append(mmScan.expectations, expectation)
	return expectation
}

// Then sets up Transaction.Scan return parameters for the expectation previously defined by the When method
func (e *TransactionMockScanExpectation) Then(err error) *TransactionMock {
	e.results = &TransactionMockScanResults{err}
	return e.mock
}

// Scan implements Transaction
func (mmScan *TransactionMock) Scan(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmScan.beforeScanCounter, 1)
	defer mm_atomic.AddUint64(&mmScan.afterScanCounter, 1)

	if mmScan.inspectFuncScan != nil {
		mmScan.inspectFuncScan(ctx, scanner, sql, args...)
	}

	mm_params := &TransactionMockScanParams{ctx, scanner, sql, args}

	// Record call args
	mmScan.ScanMock.mutex.Lock()
	mmScan.ScanMock.callArgs = append(mmScan.ScanMock.callArgs, mm_params)
	mmScan.ScanMock.mutex.Unlock()

	for _, e := range mmScan.ScanMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmScan.ScanMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScan.ScanMock.defaultExpectation.Counter, 1)
		mm_want := mmScan.ScanMock.defaultExpectation.params
		mm_got := TransactionMockScanParams{ctx, scanner, sql, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScan.t.Errorf("TransactionMock.Scan got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScan.ScanMock.defaultExpectation.results
		if mm_results == nil {
			mmScan.t.Fatal("No results are set for the TransactionMock.Scan")
		}
		return (*mm_results).err
	}
	if mmScan.funcScan != nil {
		return mmScan.funcScan(ctx, scanner, sql, args...)
	}
	mmScan.t.Fatalf("Unexpected call to TransactionMock.Scan. %v %v %v %v", ctx, scanner, sql, args)
	return
}

// ScanAfterCounter returns a count of finished TransactionMock.Scan invocations
func (mmScan *TransactionMock) ScanAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScan.afterScanCounter)
}

// ScanBeforeCounter returns a count of TransactionMock.Scan invocations
func (mmScan *TransactionMock) ScanBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScan.beforeScanCounter)
}

// Calls returns a list of arguments used in each call to TransactionMock.Scan.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScan *mTransactionMockScan) Calls() []*TransactionMockScanParams {
	mmScan.mutex.RLock()

	argCopy := make([]*TransactionMockScanParams, len(mmScan.callArgs))
	copy(argCopy, mmScan.callArgs)

	mmScan.mutex.RUnlock()

	return argCopy
}

// MinimockScanDone returns true if the count of the Scan invocations corresponds
// the number of defined expectations
func (m *TransactionMock) MinimockScanDone() bool {
	for _, e := range m.ScanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScan != nil && mm_atomic.LoadUint64(&m.afterScanCounter) < 1 {
		return false
	}
	return true
}

// MinimockScanInspect logs each unmet expectation
func (m *TransactionMock) MinimockScanInspect() {
	for _, e := range m.ScanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionMock.Scan with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanCounter) < 1 {
		if m.ScanMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransactionMock.Scan")
		} else {
			m.t.Errorf("Expected call to TransactionMock.Scan with params: %#v", *m.ScanMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScan != nil && mm_atomic.LoadUint64(&m.afterScanCounter) < 1 {
		m.t.Error("Expected call to TransactionMock.Scan")
	}
}

type mTransactionMockScanOne struct {
	mock               *TransactionMock
	defaultExpectation *TransactionMockScanOneExpectation
	expectations       []*TransactionMockScanOneExpectation

	callArgs []*TransactionMockScanOneParams
	mutex    sync.RWMutex
}

// TransactionMockScanOneExpectation specifies expectation struct of the Transaction.ScanOne
type TransactionMockScanOneExpectation struct {
	mock    *TransactionMock
	params  *TransactionMockScanOneParams
	results *TransactionMockScanOneResults
	Counter uint64
}

// TransactionMockScanOneParams contains parameters of the Transaction.ScanOne
type TransactionMockScanOneParams struct {
	ctx     context.Context
	scanner RowScanner
	sql     string
	args    []interface{}
}

// TransactionMockScanOneResults contains results of the Transaction.ScanOne
type TransactionMockScanOneResults struct {
	err error
}

// Expect sets up expected params for Transaction.ScanOne
func (mmScanOne *mTransactionMockScanOne) Expect(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) *mTransactionMockScanOne {
	if mmScanOne.mock.funcScanOne != nil {
		mmScanOne.mock.t.Fatalf("TransactionMock.ScanOne mock is already set by Set")
	}

	if mmScanOne.defaultExpectation == nil {
		mmScanOne.defaultExpectation = &TransactionMockScanOneExpectation{}
	}

	mmScanOne.defaultExpectation.params = &TransactionMockScanOneParams{ctx, scanner, sql, args}
	for _, e := range mmScanOne.expectations {
		if minimock.Equal(e.params, mmScanOne.defaultExpectation.params) {
			mmScanOne.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScanOne.defaultExpectation.params)
		}
	}

	return mmScanOne
}

// Inspect accepts an inspector function that has same arguments as the Transaction.ScanOne
func (mmScanOne *mTransactionMockScanOne) Inspect(f func(ctx context.Context, scanner RowScanner, sql string, args ...interface{})) *mTransactionMockScanOne {
	if mmScanOne.mock.inspectFuncScanOne != nil {
		mmScanOne.mock.t.Fatalf("Inspect function is already set for TransactionMock.ScanOne")
	}

	mmScanOne.mock.inspectFuncScanOne = f

	return mmScanOne
}

// Return sets up results that will be returned by Transaction.ScanOne
func (mmScanOne *mTransactionMockScanOne) Return(err error) *TransactionMock {
	if mmScanOne.mock.funcScanOne != nil {
		mmScanOne.mock.t.Fatalf("TransactionMock.ScanOne mock is already set by Set")
	}

	if mmScanOne.defaultExpectation == nil {
		mmScanOne.defaultExpectation = &TransactionMockScanOneExpectation{mock: mmScanOne.mock}
	}
	mmScanOne.defaultExpectation.results = &TransactionMockScanOneResults{err}
	return mmScanOne.mock
}

//Set uses given function f to mock the Transaction.ScanOne method
func (mmScanOne *mTransactionMockScanOne) Set(f func(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) (err error)) *TransactionMock {
	if mmScanOne.defaultExpectation != nil {
		mmScanOne.mock.t.Fatalf("Default expectation is already set for the Transaction.ScanOne method")
	}

	if len(mmScanOne.expectations) > 0 {
		mmScanOne.mock.t.Fatalf("Some expectations are already set for the Transaction.ScanOne method")
	}

	mmScanOne.mock.funcScanOne = f
	return mmScanOne.mock
}

// When sets expectation for the Transaction.ScanOne which will trigger the result defined by the following
// Then helper
func (mmScanOne *mTransactionMockScanOne) When(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) *TransactionMockScanOneExpectation {
	if mmScanOne.mock.funcScanOne != nil {
		mmScanOne.mock.t.Fatalf("TransactionMock.ScanOne mock is already set by Set")
	}

	expectation := &TransactionMockScanOneExpectation{
		mock:   mmScanOne.mock,
		params: &TransactionMockScanOneParams{ctx, scanner, sql, args},
	}
	mmScanOne.expectations = append(mmScanOne.expectations, expectation)
	return expectation
}

// Then sets up Transaction.ScanOne return parameters for the expectation previously defined by the When method
func (e *TransactionMockScanOneExpectation) Then(err error) *TransactionMock {
	e.results = &TransactionMockScanOneResults{err}
	return e.mock
}

// ScanOne implements Transaction
func (mmScanOne *TransactionMock) ScanOne(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmScanOne.beforeScanOneCounter, 1)
	defer mm_atomic.AddUint64(&mmScanOne.afterScanOneCounter, 1)

	if mmScanOne.inspectFuncScanOne != nil {
		mmScanOne.inspectFuncScanOne(ctx, scanner, sql, args...)
	}

	mm_params := &TransactionMockScanOneParams{ctx, scanner, sql, args}

	// Record call args
	mmScanOne.ScanOneMock.mutex.Lock()
	mmScanOne.ScanOneMock.callArgs = append(mmScanOne.ScanOneMock.callArgs, mm_params)
	mmScanOne.ScanOneMock.mutex.Unlock()

	for _, e := range mmScanOne.ScanOneMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmScanOne.ScanOneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScanOne.ScanOneMock.defaultExpectation.Counter, 1)
		mm_want := mmScanOne.ScanOneMock.defaultExpectation.params
		mm_got := TransactionMockScanOneParams{ctx, scanner, sql, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScanOne.t.Errorf("TransactionMock.ScanOne got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScanOne.ScanOneMock.defaultExpectation.results
		if mm_results == nil {
			mmScanOne.t.Fatal("No results are set for the TransactionMock.ScanOne")
		}
		return (*mm_results).err
	}
	if mmScanOne.funcScanOne != nil {
		return mmScanOne.funcScanOne(ctx, scanner, sql, args...)
	}
	mmScanOne.t.Fatalf("Unexpected call to TransactionMock.ScanOne. %v %v %v %v", ctx, scanner, sql, args)
	return
}

// ScanOneAfterCounter returns a count of finished TransactionMock.ScanOne invocations
func (mmScanOne *TransactionMock) ScanOneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanOne.afterScanOneCounter)
}

// ScanOneBeforeCounter returns a count of TransactionMock.ScanOne invocations
func (mmScanOne *TransactionMock) ScanOneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanOne.beforeScanOneCounter)
}

// Calls returns a list of arguments used in each call to TransactionMock.ScanOne.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScanOne *mTransactionMockScanOne) Calls() []*TransactionMockScanOneParams {
	mmScanOne.mutex.RLock()

	argCopy := make([]*TransactionMockScanOneParams, len(mmScanOne.callArgs))
	copy(argCopy, mmScanOne.callArgs)

	mmScanOne.mutex.RUnlock()

	return argCopy
}

// MinimockScanOneDone returns true if the count of the ScanOne invocations corresponds
// the number of defined expectations
func (m *TransactionMock) MinimockScanOneDone() bool {
	for _, e := range m.ScanOneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanOneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanOneCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanOne != nil && mm_atomic.LoadUint64(&m.afterScanOneCounter) < 1 {
		return false
	}
	return true
}

// MinimockScanOneInspect logs each unmet expectation
func (m *TransactionMock) MinimockScanOneInspect() {
	for _, e := range m.ScanOneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionMock.ScanOne with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanOneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanOneCounter) < 1 {
		if m.ScanOneMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransactionMock.ScanOne")
		} else {
			m.t.Errorf("Expected call to TransactionMock.ScanOne with params: %#v", *m.ScanOneMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanOne != nil && mm_atomic.LoadUint64(&m.afterScanOneCounter) < 1 {
		m.t.Error("Expected call to TransactionMock.ScanOne")
	}
}

type mTransactionMockUpdate struct {
	mock               *TransactionMock
	defaultExpectation *TransactionMockUpdateExpectation
	expectations       []*TransactionMockUpdateExpectation

	callArgs []*TransactionMockUpdateParams
	mutex    sync.RWMutex
}

// TransactionMockUpdateExpectation specifies expectation struct of the Transaction.Update
type TransactionMockUpdateExpectation struct {
	mock    *TransactionMock
	params  *TransactionMockUpdateParams
	results *TransactionMockUpdateResults
	Counter uint64
}

// TransactionMockUpdateParams contains parameters of the Transaction.Update
type TransactionMockUpdateParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// TransactionMockUpdateResults contains results of the Transaction.Update
type TransactionMockUpdateResults struct {
	r1  sql.Result
	err error
}

// Expect sets up expected params for Transaction.Update
func (mmUpdate *mTransactionMockUpdate) Expect(ctx context.Context, sql string, args ...interface{}) *mTransactionMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TransactionMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &TransactionMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &TransactionMockUpdateParams{ctx, sql, args}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Transaction.Update
func (mmUpdate *mTransactionMockUpdate) Inspect(f func(ctx context.Context, sql string, args ...interface{})) *mTransactionMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for TransactionMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Transaction.Update
func (mmUpdate *mTransactionMockUpdate) Return(r1 sql.Result, err error) *TransactionMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TransactionMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &TransactionMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &TransactionMockUpdateResults{r1, err}
	return mmUpdate.mock
}

//Set uses given function f to mock the Transaction.Update method
func (mmUpdate *mTransactionMockUpdate) Set(f func(ctx context.Context, sql string, args ...interface{}) (r1 sql.Result, err error)) *TransactionMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Transaction.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Transaction.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the Transaction.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mTransactionMockUpdate) When(ctx context.Context, sql string, args ...interface{}) *TransactionMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("TransactionMock.Update mock is already set by Set")
	}

	expectation := &TransactionMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &TransactionMockUpdateParams{ctx, sql, args},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Transaction.Update return parameters for the expectation previously defined by the When method
func (e *TransactionMockUpdateExpectation) Then(r1 sql.Result, err error) *TransactionMock {
	e.results = &TransactionMockUpdateResults{r1, err}
	return e.mock
}

// Update implements Transaction
func (mmUpdate *TransactionMock) Update(ctx context.Context, sql string, args ...interface{}) (r1 sql.Result, err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, sql, args...)
	}

	mm_params := &TransactionMockUpdateParams{ctx, sql, args}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := TransactionMockUpdateParams{ctx, sql, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("TransactionMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the TransactionMock.Update")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, sql, args...)
	}
	mmUpdate.t.Fatalf("Unexpected call to TransactionMock.Update. %v %v %v", ctx, sql, args)
	return
}

// UpdateAfterCounter returns a count of finished TransactionMock.Update invocations
func (mmUpdate *TransactionMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of TransactionMock.Update invocations
func (mmUpdate *TransactionMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to TransactionMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mTransactionMockUpdate) Calls() []*TransactionMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*TransactionMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *TransactionMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *TransactionMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransactionMock.Update")
		} else {
			m.t.Errorf("Expected call to TransactionMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to TransactionMock.Update")
	}
}

type mTransactionMockUpdateAndGetLastInsertID struct {
	mock               *TransactionMock
	defaultExpectation *TransactionMockUpdateAndGetLastInsertIDExpectation
	expectations       []*TransactionMockUpdateAndGetLastInsertIDExpectation

	callArgs []*TransactionMockUpdateAndGetLastInsertIDParams
	mutex    sync.RWMutex
}

// TransactionMockUpdateAndGetLastInsertIDExpectation specifies expectation struct of the Transaction.UpdateAndGetLastInsertID
type TransactionMockUpdateAndGetLastInsertIDExpectation struct {
	mock    *TransactionMock
	params  *TransactionMockUpdateAndGetLastInsertIDParams
	results *TransactionMockUpdateAndGetLastInsertIDResults
	Counter uint64
}

// TransactionMockUpdateAndGetLastInsertIDParams contains parameters of the Transaction.UpdateAndGetLastInsertID
type TransactionMockUpdateAndGetLastInsertIDParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// TransactionMockUpdateAndGetLastInsertIDResults contains results of the Transaction.UpdateAndGetLastInsertID
type TransactionMockUpdateAndGetLastInsertIDResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Transaction.UpdateAndGetLastInsertID
func (mmUpdateAndGetLastInsertID *mTransactionMockUpdateAndGetLastInsertID) Expect(ctx context.Context, sql string, args ...interface{}) *mTransactionMockUpdateAndGetLastInsertID {
	if mmUpdateAndGetLastInsertID.mock.funcUpdateAndGetLastInsertID != nil {
		mmUpdateAndGetLastInsertID.mock.t.Fatalf("TransactionMock.UpdateAndGetLastInsertID mock is already set by Set")
	}

	if mmUpdateAndGetLastInsertID.defaultExpectation == nil {
		mmUpdateAndGetLastInsertID.defaultExpectation = &TransactionMockUpdateAndGetLastInsertIDExpectation{}
	}

	mmUpdateAndGetLastInsertID.defaultExpectation.params = &TransactionMockUpdateAndGetLastInsertIDParams{ctx, sql, args}
	for _, e := range mmUpdateAndGetLastInsertID.expectations {
		if minimock.Equal(e.params, mmUpdateAndGetLastInsertID.defaultExpectation.params) {
			mmUpdateAndGetLastInsertID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateAndGetLastInsertID.defaultExpectation.params)
		}
	}

	return mmUpdateAndGetLastInsertID
}

// Inspect accepts an inspector function that has same arguments as the Transaction.UpdateAndGetLastInsertID
func (mmUpdateAndGetLastInsertID *mTransactionMockUpdateAndGetLastInsertID) Inspect(f func(ctx context.Context, sql string, args ...interface{})) *mTransactionMockUpdateAndGetLastInsertID {
	if mmUpdateAndGetLastInsertID.mock.inspectFuncUpdateAndGetLastInsertID != nil {
		mmUpdateAndGetLastInsertID.mock.t.Fatalf("Inspect function is already set for TransactionMock.UpdateAndGetLastInsertID")
	}

	mmUpdateAndGetLastInsertID.mock.inspectFuncUpdateAndGetLastInsertID = f

	return mmUpdateAndGetLastInsertID
}

// Return sets up results that will be returned by Transaction.UpdateAndGetLastInsertID
func (mmUpdateAndGetLastInsertID *mTransactionMockUpdateAndGetLastInsertID) Return(i1 int64, err error) *TransactionMock {
	if mmUpdateAndGetLastInsertID.mock.funcUpdateAndGetLastInsertID != nil {
		mmUpdateAndGetLastInsertID.mock.t.Fatalf("TransactionMock.UpdateAndGetLastInsertID mock is already set by Set")
	}

	if mmUpdateAndGetLastInsertID.defaultExpectation == nil {
		mmUpdateAndGetLastInsertID.defaultExpectation = &TransactionMockUpdateAndGetLastInsertIDExpectation{mock: mmUpdateAndGetLastInsertID.mock}
	}
	mmUpdateAndGetLastInsertID.defaultExpectation.results = &TransactionMockUpdateAndGetLastInsertIDResults{i1, err}
	return mmUpdateAndGetLastInsertID.mock
}

//Set uses given function f to mock the Transaction.UpdateAndGetLastInsertID method
func (mmUpdateAndGetLastInsertID *mTransactionMockUpdateAndGetLastInsertID) Set(f func(ctx context.Context, sql string, args ...interface{}) (i1 int64, err error)) *TransactionMock {
	if mmUpdateAndGetLastInsertID.defaultExpectation != nil {
		mmUpdateAndGetLastInsertID.mock.t.Fatalf("Default expectation is already set for the Transaction.UpdateAndGetLastInsertID method")
	}

	if len(mmUpdateAndGetLastInsertID.expectations) > 0 {
		mmUpdateAndGetLastInsertID.mock.t.Fatalf("Some expectations are already set for the Transaction.UpdateAndGetLastInsertID method")
	}

	mmUpdateAndGetLastInsertID.mock.funcUpdateAndGetLastInsertID = f
	return mmUpdateAndGetLastInsertID.mock
}

// When sets expectation for the Transaction.UpdateAndGetLastInsertID which will trigger the result defined by the following
// Then helper
func (mmUpdateAndGetLastInsertID *mTransactionMockUpdateAndGetLastInsertID) When(ctx context.Context, sql string, args ...interface{}) *TransactionMockUpdateAndGetLastInsertIDExpectation {
	if mmUpdateAndGetLastInsertID.mock.funcUpdateAndGetLastInsertID != nil {
		mmUpdateAndGetLastInsertID.mock.t.Fatalf("TransactionMock.UpdateAndGetLastInsertID mock is already set by Set")
	}

	expectation := &TransactionMockUpdateAndGetLastInsertIDExpectation{
		mock:   mmUpdateAndGetLastInsertID.mock,
		params: &TransactionMockUpdateAndGetLastInsertIDParams{ctx, sql, args},
	}
	mmUpdateAndGetLastInsertID.expectations = append(mmUpdateAndGetLastInsertID.expectations, expectation)
	return expectation
}

// Then sets up Transaction.UpdateAndGetLastInsertID return parameters for the expectation previously defined by the When method
func (e *TransactionMockUpdateAndGetLastInsertIDExpectation) Then(i1 int64, err error) *TransactionMock {
	e.results = &TransactionMockUpdateAndGetLastInsertIDResults{i1, err}
	return e.mock
}

// UpdateAndGetLastInsertID implements Transaction
func (mmUpdateAndGetLastInsertID *TransactionMock) UpdateAndGetLastInsertID(ctx context.Context, sql string, args ...interface{}) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmUpdateAndGetLastInsertID.beforeUpdateAndGetLastInsertIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateAndGetLastInsertID.afterUpdateAndGetLastInsertIDCounter, 1)

	if mmUpdateAndGetLastInsertID.inspectFuncUpdateAndGetLastInsertID != nil {
		mmUpdateAndGetLastInsertID.inspectFuncUpdateAndGetLastInsertID(ctx, sql, args...)
	}

	mm_params := &TransactionMockUpdateAndGetLastInsertIDParams{ctx, sql, args}

	// Record call args
	mmUpdateAndGetLastInsertID.UpdateAndGetLastInsertIDMock.mutex.Lock()
	mmUpdateAndGetLastInsertID.UpdateAndGetLastInsertIDMock.callArgs = append(mmUpdateAndGetLastInsertID.UpdateAndGetLastInsertIDMock.callArgs, mm_params)
	mmUpdateAndGetLastInsertID.UpdateAndGetLastInsertIDMock.mutex.Unlock()

	for _, e := range mmUpdateAndGetLastInsertID.UpdateAndGetLastInsertIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmUpdateAndGetLastInsertID.UpdateAndGetLastInsertIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateAndGetLastInsertID.UpdateAndGetLastInsertIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateAndGetLastInsertID.UpdateAndGetLastInsertIDMock.defaultExpectation.params
		mm_got := TransactionMockUpdateAndGetLastInsertIDParams{ctx, sql, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateAndGetLastInsertID.t.Errorf("TransactionMock.UpdateAndGetLastInsertID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateAndGetLastInsertID.UpdateAndGetLastInsertIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateAndGetLastInsertID.t.Fatal("No results are set for the TransactionMock.UpdateAndGetLastInsertID")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmUpdateAndGetLastInsertID.funcUpdateAndGetLastInsertID != nil {
		return mmUpdateAndGetLastInsertID.funcUpdateAndGetLastInsertID(ctx, sql, args...)
	}
	mmUpdateAndGetLastInsertID.t.Fatalf("Unexpected call to TransactionMock.UpdateAndGetLastInsertID. %v %v %v", ctx, sql, args)
	return
}

// UpdateAndGetLastInsertIDAfterCounter returns a count of finished TransactionMock.UpdateAndGetLastInsertID invocations
func (mmUpdateAndGetLastInsertID *TransactionMock) UpdateAndGetLastInsertIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAndGetLastInsertID.afterUpdateAndGetLastInsertIDCounter)
}

// UpdateAndGetLastInsertIDBeforeCounter returns a count of TransactionMock.UpdateAndGetLastInsertID invocations
func (mmUpdateAndGetLastInsertID *TransactionMock) UpdateAndGetLastInsertIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAndGetLastInsertID.beforeUpdateAndGetLastInsertIDCounter)
}

// Calls returns a list of arguments used in each call to TransactionMock.UpdateAndGetLastInsertID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateAndGetLastInsertID *mTransactionMockUpdateAndGetLastInsertID) Calls() []*TransactionMockUpdateAndGetLastInsertIDParams {
	mmUpdateAndGetLastInsertID.mutex.RLock()

	argCopy := make([]*TransactionMockUpdateAndGetLastInsertIDParams, len(mmUpdateAndGetLastInsertID.callArgs))
	copy(argCopy, mmUpdateAndGetLastInsertID.callArgs)

	mmUpdateAndGetLastInsertID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateAndGetLastInsertIDDone returns true if the count of the UpdateAndGetLastInsertID invocations corresponds
// the number of defined expectations
func (m *TransactionMock) MinimockUpdateAndGetLastInsertIDDone() bool {
	for _, e := range m.UpdateAndGetLastInsertIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAndGetLastInsertIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetLastInsertIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAndGetLastInsertID != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetLastInsertIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateAndGetLastInsertIDInspect logs each unmet expectation
func (m *TransactionMock) MinimockUpdateAndGetLastInsertIDInspect() {
	for _, e := range m.UpdateAndGetLastInsertIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionMock.UpdateAndGetLastInsertID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAndGetLastInsertIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetLastInsertIDCounter) < 1 {
		if m.UpdateAndGetLastInsertIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransactionMock.UpdateAndGetLastInsertID")
		} else {
			m.t.Errorf("Expected call to TransactionMock.UpdateAndGetLastInsertID with params: %#v", *m.UpdateAndGetLastInsertIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAndGetLastInsertID != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetLastInsertIDCounter) < 1 {
		m.t.Error("Expected call to TransactionMock.UpdateAndGetLastInsertID")
	}
}

type mTransactionMockUpdateAndGetRowsAffected struct {
	mock               *TransactionMock
	defaultExpectation *TransactionMockUpdateAndGetRowsAffectedExpectation
	expectations       []*TransactionMockUpdateAndGetRowsAffectedExpectation

	callArgs []*TransactionMockUpdateAndGetRowsAffectedParams
	mutex    sync.RWMutex
}

// TransactionMockUpdateAndGetRowsAffectedExpectation specifies expectation struct of the Transaction.UpdateAndGetRowsAffected
type TransactionMockUpdateAndGetRowsAffectedExpectation struct {
	mock    *TransactionMock
	params  *TransactionMockUpdateAndGetRowsAffectedParams
	results *TransactionMockUpdateAndGetRowsAffectedResults
	Counter uint64
}

// TransactionMockUpdateAndGetRowsAffectedParams contains parameters of the Transaction.UpdateAndGetRowsAffected
type TransactionMockUpdateAndGetRowsAffectedParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// TransactionMockUpdateAndGetRowsAffectedResults contains results of the Transaction.UpdateAndGetRowsAffected
type TransactionMockUpdateAndGetRowsAffectedResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Transaction.UpdateAndGetRowsAffected
func (mmUpdateAndGetRowsAffected *mTransactionMockUpdateAndGetRowsAffected) Expect(ctx context.Context, sql string, args ...interface{}) *mTransactionMockUpdateAndGetRowsAffected {
	if mmUpdateAndGetRowsAffected.mock.funcUpdateAndGetRowsAffected != nil {
		mmUpdateAndGetRowsAffected.mock.t.Fatalf("TransactionMock.UpdateAndGetRowsAffected mock is already set by Set")
	}

	if mmUpdateAndGetRowsAffected.defaultExpectation == nil {
		mmUpdateAndGetRowsAffected.defaultExpectation = &TransactionMockUpdateAndGetRowsAffectedExpectation{}
	}

	mmUpdateAndGetRowsAffected.defaultExpectation.params = &TransactionMockUpdateAndGetRowsAffectedParams{ctx, sql, args}
	for _, e := range mmUpdateAndGetRowsAffected.expectations {
		if minimock.Equal(e.params, mmUpdateAndGetRowsAffected.defaultExpectation.params) {
			mmUpdateAndGetRowsAffected.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateAndGetRowsAffected.defaultExpectation.params)
		}
	}

	return mmUpdateAndGetRowsAffected
}

// Inspect accepts an inspector function that has same arguments as the Transaction.UpdateAndGetRowsAffected
func (mmUpdateAndGetRowsAffected *mTransactionMockUpdateAndGetRowsAffected) Inspect(f func(ctx context.Context, sql string, args ...interface{})) *mTransactionMockUpdateAndGetRowsAffected {
	if mmUpdateAndGetRowsAffected.mock.inspectFuncUpdateAndGetRowsAffected != nil {
		mmUpdateAndGetRowsAffected.mock.t.Fatalf("Inspect function is already set for TransactionMock.UpdateAndGetRowsAffected")
	}

	mmUpdateAndGetRowsAffected.mock.inspectFuncUpdateAndGetRowsAffected = f

	return mmUpdateAndGetRowsAffected
}

// Return sets up results that will be returned by Transaction.UpdateAndGetRowsAffected
func (mmUpdateAndGetRowsAffected *mTransactionMockUpdateAndGetRowsAffected) Return(i1 int64, err error) *TransactionMock {
	if mmUpdateAndGetRowsAffected.mock.funcUpdateAndGetRowsAffected != nil {
		mmUpdateAndGetRowsAffected.mock.t.Fatalf("TransactionMock.UpdateAndGetRowsAffected mock is already set by Set")
	}

	if mmUpdateAndGetRowsAffected.defaultExpectation == nil {
		mmUpdateAndGetRowsAffected.defaultExpectation = &TransactionMockUpdateAndGetRowsAffectedExpectation{mock: mmUpdateAndGetRowsAffected.mock}
	}
	mmUpdateAndGetRowsAffected.defaultExpectation.results = &TransactionMockUpdateAndGetRowsAffectedResults{i1, err}
	return mmUpdateAndGetRowsAffected.mock
}

//Set uses given function f to mock the Transaction.UpdateAndGetRowsAffected method
func (mmUpdateAndGetRowsAffected *mTransactionMockUpdateAndGetRowsAffected) Set(f func(ctx context.Context, sql string, args ...interface{}) (i1 int64, err error)) *TransactionMock {
	if mmUpdateAndGetRowsAffected.defaultExpectation != nil {
		mmUpdateAndGetRowsAffected.mock.t.Fatalf("Default expectation is already set for the Transaction.UpdateAndGetRowsAffected method")
	}

	if len(mmUpdateAndGetRowsAffected.expectations) > 0 {
		mmUpdateAndGetRowsAffected.mock.t.Fatalf("Some expectations are already set for the Transaction.UpdateAndGetRowsAffected method")
	}

	mmUpdateAndGetRowsAffected.mock.funcUpdateAndGetRowsAffected = f
	return mmUpdateAndGetRowsAffected.mock
}

// When sets expectation for the Transaction.UpdateAndGetRowsAffected which will trigger the result defined by the following
// Then helper
func (mmUpdateAndGetRowsAffected *mTransactionMockUpdateAndGetRowsAffected) When(ctx context.Context, sql string, args ...interface{}) *TransactionMockUpdateAndGetRowsAffectedExpectation {
	if mmUpdateAndGetRowsAffected.mock.funcUpdateAndGetRowsAffected != nil {
		mmUpdateAndGetRowsAffected.mock.t.Fatalf("TransactionMock.UpdateAndGetRowsAffected mock is already set by Set")
	}

	expectation := &TransactionMockUpdateAndGetRowsAffectedExpectation{
		mock:   mmUpdateAndGetRowsAffected.mock,
		params: &TransactionMockUpdateAndGetRowsAffectedParams{ctx, sql, args},
	}
	mmUpdateAndGetRowsAffected.expectations = append(mmUpdateAndGetRowsAffected.expectations, expectation)
	return expectation
}

// Then sets up Transaction.UpdateAndGetRowsAffected return parameters for the expectation previously defined by the When method
func (e *TransactionMockUpdateAndGetRowsAffectedExpectation) Then(i1 int64, err error) *TransactionMock {
	e.results = &TransactionMockUpdateAndGetRowsAffectedResults{i1, err}
	return e.mock
}

// UpdateAndGetRowsAffected implements Transaction
func (mmUpdateAndGetRowsAffected *TransactionMock) UpdateAndGetRowsAffected(ctx context.Context, sql string, args ...interface{}) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmUpdateAndGetRowsAffected.beforeUpdateAndGetRowsAffectedCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateAndGetRowsAffected.afterUpdateAndGetRowsAffectedCounter, 1)

	if mmUpdateAndGetRowsAffected.inspectFuncUpdateAndGetRowsAffected != nil {
		mmUpdateAndGetRowsAffected.inspectFuncUpdateAndGetRowsAffected(ctx, sql, args...)
	}

	mm_params := &TransactionMockUpdateAndGetRowsAffectedParams{ctx, sql, args}

	// Record call args
	mmUpdateAndGetRowsAffected.UpdateAndGetRowsAffectedMock.mutex.Lock()
	mmUpdateAndGetRowsAffected.UpdateAndGetRowsAffectedMock.callArgs = append(mmUpdateAndGetRowsAffected.UpdateAndGetRowsAffectedMock.callArgs, mm_params)
	mmUpdateAndGetRowsAffected.UpdateAndGetRowsAffectedMock.mutex.Unlock()

	for _, e := range mmUpdateAndGetRowsAffected.UpdateAndGetRowsAffectedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmUpdateAndGetRowsAffected.UpdateAndGetRowsAffectedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateAndGetRowsAffected.UpdateAndGetRowsAffectedMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateAndGetRowsAffected.UpdateAndGetRowsAffectedMock.defaultExpectation.params
		mm_got := TransactionMockUpdateAndGetRowsAffectedParams{ctx, sql, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateAndGetRowsAffected.t.Errorf("TransactionMock.UpdateAndGetRowsAffected got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateAndGetRowsAffected.UpdateAndGetRowsAffectedMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateAndGetRowsAffected.t.Fatal("No results are set for the TransactionMock.UpdateAndGetRowsAffected")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmUpdateAndGetRowsAffected.funcUpdateAndGetRowsAffected != nil {
		return mmUpdateAndGetRowsAffected.funcUpdateAndGetRowsAffected(ctx, sql, args...)
	}
	mmUpdateAndGetRowsAffected.t.Fatalf("Unexpected call to TransactionMock.UpdateAndGetRowsAffected. %v %v %v", ctx, sql, args)
	return
}

// UpdateAndGetRowsAffectedAfterCounter returns a count of finished TransactionMock.UpdateAndGetRowsAffected invocations
func (mmUpdateAndGetRowsAffected *TransactionMock) UpdateAndGetRowsAffectedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAndGetRowsAffected.afterUpdateAndGetRowsAffectedCounter)
}

// UpdateAndGetRowsAffectedBeforeCounter returns a count of TransactionMock.UpdateAndGetRowsAffected invocations
func (mmUpdateAndGetRowsAffected *TransactionMock) UpdateAndGetRowsAffectedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAndGetRowsAffected.beforeUpdateAndGetRowsAffectedCounter)
}

// Calls returns a list of arguments used in each call to TransactionMock.UpdateAndGetRowsAffected.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateAndGetRowsAffected *mTransactionMockUpdateAndGetRowsAffected) Calls() []*TransactionMockUpdateAndGetRowsAffectedParams {
	mmUpdateAndGetRowsAffected.mutex.RLock()

	argCopy := make([]*TransactionMockUpdateAndGetRowsAffectedParams, len(mmUpdateAndGetRowsAffected.callArgs))
	copy(argCopy, mmUpdateAndGetRowsAffected.callArgs)

	mmUpdateAndGetRowsAffected.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateAndGetRowsAffectedDone returns true if the count of the UpdateAndGetRowsAffected invocations corresponds
// the number of defined expectations
func (m *TransactionMock) MinimockUpdateAndGetRowsAffectedDone() bool {
	for _, e := range m.UpdateAndGetRowsAffectedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAndGetRowsAffectedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetRowsAffectedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAndGetRowsAffected != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetRowsAffectedCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateAndGetRowsAffectedInspect logs each unmet expectation
func (m *TransactionMock) MinimockUpdateAndGetRowsAffectedInspect() {
	for _, e := range m.UpdateAndGetRowsAffectedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionMock.UpdateAndGetRowsAffected with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAndGetRowsAffectedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetRowsAffectedCounter) < 1 {
		if m.UpdateAndGetRowsAffectedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransactionMock.UpdateAndGetRowsAffected")
		} else {
			m.t.Errorf("Expected call to TransactionMock.UpdateAndGetRowsAffected with params: %#v", *m.UpdateAndGetRowsAffectedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAndGetRowsAffected != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetRowsAffectedCounter) < 1 {
		m.t.Error("Expected call to TransactionMock.UpdateAndGetRowsAffected")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TransactionMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockPreparedInspect()

		m.MinimockScanInspect()

		m.MinimockScanOneInspect()

		m.MinimockUpdateInspect()

		m.MinimockUpdateAndGetLastInsertIDInspect()

		m.MinimockUpdateAndGetRowsAffectedInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TransactionMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TransactionMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockPreparedDone() &&
		m.MinimockScanDone() &&
		m.MinimockScanOneDone() &&
		m.MinimockUpdateDone() &&
		m.MinimockUpdateAndGetLastInsertIDDone() &&
		m.MinimockUpdateAndGetRowsAffectedDone()
}
