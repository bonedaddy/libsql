package libsql

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"database/sql"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// DatabaseMock implements Database
type DatabaseMock struct {
	t minimock.Tester

	funcClose          func() (err error)
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mDatabaseMockClose

	funcPrepared          func(ctx context.Context, sql string, work func(Statement) error) (err error)
	afterPreparedCounter  uint64
	beforePreparedCounter uint64
	PreparedMock          mDatabaseMockPrepared

	funcScan          func(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) (err error)
	afterScanCounter  uint64
	beforeScanCounter uint64
	ScanMock          mDatabaseMockScan

	funcScanOne          func(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) (err error)
	afterScanOneCounter  uint64
	beforeScanOneCounter uint64
	ScanOneMock          mDatabaseMockScanOne

	funcTransaction          func(ctx context.Context, work func(Transaction) error) (err error)
	afterTransactionCounter  uint64
	beforeTransactionCounter uint64
	TransactionMock          mDatabaseMockTransaction

	funcUpdate          func(ctx context.Context, sql string, args ...interface{}) (r1 sql.Result, err error)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mDatabaseMockUpdate

	funcUpdateAndGetLastInsertID          func(ctx context.Context, sql string, args ...interface{}) (i1 int64, err error)
	afterUpdateAndGetLastInsertIDCounter  uint64
	beforeUpdateAndGetLastInsertIDCounter uint64
	UpdateAndGetLastInsertIDMock          mDatabaseMockUpdateAndGetLastInsertID

	funcUpdateAndGetRowsAffected          func(ctx context.Context, sql string, args ...interface{}) (i1 int64, err error)
	afterUpdateAndGetRowsAffectedCounter  uint64
	beforeUpdateAndGetRowsAffectedCounter uint64
	UpdateAndGetRowsAffectedMock          mDatabaseMockUpdateAndGetRowsAffected
}

// NewDatabaseMock returns a mock for Database
func NewDatabaseMock(t minimock.Tester) *DatabaseMock {
	m := &DatabaseMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}
	m.CloseMock = mDatabaseMockClose{mock: m}
	m.PreparedMock = mDatabaseMockPrepared{mock: m}
	m.ScanMock = mDatabaseMockScan{mock: m}
	m.ScanOneMock = mDatabaseMockScanOne{mock: m}
	m.TransactionMock = mDatabaseMockTransaction{mock: m}
	m.UpdateMock = mDatabaseMockUpdate{mock: m}
	m.UpdateAndGetLastInsertIDMock = mDatabaseMockUpdateAndGetLastInsertID{mock: m}
	m.UpdateAndGetRowsAffectedMock = mDatabaseMockUpdateAndGetRowsAffected{mock: m}

	return m
}

type mDatabaseMockClose struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockCloseExpectation
	expectations       []*DatabaseMockCloseExpectation
}

// DatabaseMockCloseExpectation specifies expectation struct of the Database.Close
type DatabaseMockCloseExpectation struct {
	mock *DatabaseMock

	results *DatabaseMockCloseResults
	Counter uint64
}

// DatabaseMockCloseResults contains results of the Database.Close
type DatabaseMockCloseResults struct {
	err error
}

// Expect sets up expected params for Database.Close
func (m *mDatabaseMockClose) Expect() *mDatabaseMockClose {
	if m.mock.funcClose != nil {
		m.mock.t.Fatalf("DatabaseMock.Close mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockCloseExpectation{}
	}

	return m
}

// Return sets up results that will be returned by Database.Close
func (m *mDatabaseMockClose) Return(err error) *DatabaseMock {
	if m.mock.funcClose != nil {
		m.mock.t.Fatalf("DatabaseMock.Close mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockCloseExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &DatabaseMockCloseResults{err}
	return m.mock
}

//Set uses given function f to mock the Database.Close method
func (m *mDatabaseMockClose) Set(f func() (err error)) *DatabaseMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Database.Close method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Database.Close method")
	}

	m.mock.funcClose = f
	return m.mock
}

// Close implements Database
func (m *DatabaseMock) Close() (err error) {
	mm_atomic.AddUint64(&m.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&m.afterCloseCounter, 1)

	if m.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.CloseMock.defaultExpectation.Counter, 1)

		results := m.CloseMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the DatabaseMock.Close")
		}
		return (*results).err
	}
	if m.funcClose != nil {
		return m.funcClose()
	}
	m.t.Fatalf("Unexpected call to DatabaseMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished DatabaseMock.Close invocations
func (m *DatabaseMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterCloseCounter)
}

// CloseBeforeCounter returns a count of DatabaseMock.Close invocations
func (m *DatabaseMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *DatabaseMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DatabaseMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.Close")
	}
}

type mDatabaseMockPrepared struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockPreparedExpectation
	expectations       []*DatabaseMockPreparedExpectation
}

// DatabaseMockPreparedExpectation specifies expectation struct of the Database.Prepared
type DatabaseMockPreparedExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockPreparedParams
	results *DatabaseMockPreparedResults
	Counter uint64
}

// DatabaseMockPreparedParams contains parameters of the Database.Prepared
type DatabaseMockPreparedParams struct {
	ctx  context.Context
	sql  string
	work func(Statement) error
}

// DatabaseMockPreparedResults contains results of the Database.Prepared
type DatabaseMockPreparedResults struct {
	err error
}

// Expect sets up expected params for Database.Prepared
func (m *mDatabaseMockPrepared) Expect(ctx context.Context, sql string, work func(Statement) error) *mDatabaseMockPrepared {
	if m.mock.funcPrepared != nil {
		m.mock.t.Fatalf("DatabaseMock.Prepared mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockPreparedExpectation{}
	}

	m.defaultExpectation.params = &DatabaseMockPreparedParams{ctx, sql, work}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by Database.Prepared
func (m *mDatabaseMockPrepared) Return(err error) *DatabaseMock {
	if m.mock.funcPrepared != nil {
		m.mock.t.Fatalf("DatabaseMock.Prepared mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockPreparedExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &DatabaseMockPreparedResults{err}
	return m.mock
}

//Set uses given function f to mock the Database.Prepared method
func (m *mDatabaseMockPrepared) Set(f func(ctx context.Context, sql string, work func(Statement) error) (err error)) *DatabaseMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Database.Prepared method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Database.Prepared method")
	}

	m.mock.funcPrepared = f
	return m.mock
}

// When sets expectation for the Database.Prepared which will trigger the result defined by the following
// Then helper
func (m *mDatabaseMockPrepared) When(ctx context.Context, sql string, work func(Statement) error) *DatabaseMockPreparedExpectation {
	if m.mock.funcPrepared != nil {
		m.mock.t.Fatalf("DatabaseMock.Prepared mock is already set by Set")
	}

	expectation := &DatabaseMockPreparedExpectation{
		mock:   m.mock,
		params: &DatabaseMockPreparedParams{ctx, sql, work},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up Database.Prepared return parameters for the expectation previously defined by the When method
func (e *DatabaseMockPreparedExpectation) Then(err error) *DatabaseMock {
	e.results = &DatabaseMockPreparedResults{err}
	return e.mock
}

// Prepared implements Database
func (m *DatabaseMock) Prepared(ctx context.Context, sql string, work func(Statement) error) (err error) {
	mm_atomic.AddUint64(&m.beforePreparedCounter, 1)
	defer mm_atomic.AddUint64(&m.afterPreparedCounter, 1)

	for _, e := range m.PreparedMock.expectations {
		if minimock.Equal(*e.params, DatabaseMockPreparedParams{ctx, sql, work}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if m.PreparedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.PreparedMock.defaultExpectation.Counter, 1)
		want := m.PreparedMock.defaultExpectation.params
		got := DatabaseMockPreparedParams{ctx, sql, work}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("DatabaseMock.Prepared got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.PreparedMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the DatabaseMock.Prepared")
		}
		return (*results).err
	}
	if m.funcPrepared != nil {
		return m.funcPrepared(ctx, sql, work)
	}
	m.t.Fatalf("Unexpected call to DatabaseMock.Prepared. %v %v %v", ctx, sql, work)
	return
}

// PreparedAfterCounter returns a count of finished DatabaseMock.Prepared invocations
func (m *DatabaseMock) PreparedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterPreparedCounter)
}

// PreparedBeforeCounter returns a count of DatabaseMock.Prepared invocations
func (m *DatabaseMock) PreparedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforePreparedCounter)
}

// MinimockPreparedDone returns true if the count of the Prepared invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockPreparedDone() bool {
	for _, e := range m.PreparedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PreparedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPreparedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepared != nil && mm_atomic.LoadUint64(&m.afterPreparedCounter) < 1 {
		return false
	}
	return true
}

// MinimockPreparedInspect logs each unmet expectation
func (m *DatabaseMock) MinimockPreparedInspect() {
	for _, e := range m.PreparedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.Prepared with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PreparedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPreparedCounter) < 1 {
		if m.PreparedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.Prepared")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.Prepared with params: %#v", *m.PreparedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepared != nil && mm_atomic.LoadUint64(&m.afterPreparedCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.Prepared")
	}
}

type mDatabaseMockScan struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockScanExpectation
	expectations       []*DatabaseMockScanExpectation
}

// DatabaseMockScanExpectation specifies expectation struct of the Database.Scan
type DatabaseMockScanExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockScanParams
	results *DatabaseMockScanResults
	Counter uint64
}

// DatabaseMockScanParams contains parameters of the Database.Scan
type DatabaseMockScanParams struct {
	ctx     context.Context
	scanner RowScanner
	sql     string
	args    []interface{}
}

// DatabaseMockScanResults contains results of the Database.Scan
type DatabaseMockScanResults struct {
	err error
}

// Expect sets up expected params for Database.Scan
func (m *mDatabaseMockScan) Expect(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) *mDatabaseMockScan {
	if m.mock.funcScan != nil {
		m.mock.t.Fatalf("DatabaseMock.Scan mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockScanExpectation{}
	}

	m.defaultExpectation.params = &DatabaseMockScanParams{ctx, scanner, sql, args}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by Database.Scan
func (m *mDatabaseMockScan) Return(err error) *DatabaseMock {
	if m.mock.funcScan != nil {
		m.mock.t.Fatalf("DatabaseMock.Scan mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockScanExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &DatabaseMockScanResults{err}
	return m.mock
}

//Set uses given function f to mock the Database.Scan method
func (m *mDatabaseMockScan) Set(f func(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) (err error)) *DatabaseMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Database.Scan method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Database.Scan method")
	}

	m.mock.funcScan = f
	return m.mock
}

// When sets expectation for the Database.Scan which will trigger the result defined by the following
// Then helper
func (m *mDatabaseMockScan) When(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) *DatabaseMockScanExpectation {
	if m.mock.funcScan != nil {
		m.mock.t.Fatalf("DatabaseMock.Scan mock is already set by Set")
	}

	expectation := &DatabaseMockScanExpectation{
		mock:   m.mock,
		params: &DatabaseMockScanParams{ctx, scanner, sql, args},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up Database.Scan return parameters for the expectation previously defined by the When method
func (e *DatabaseMockScanExpectation) Then(err error) *DatabaseMock {
	e.results = &DatabaseMockScanResults{err}
	return e.mock
}

// Scan implements Database
func (m *DatabaseMock) Scan(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&m.beforeScanCounter, 1)
	defer mm_atomic.AddUint64(&m.afterScanCounter, 1)

	for _, e := range m.ScanMock.expectations {
		if minimock.Equal(*e.params, DatabaseMockScanParams{ctx, scanner, sql, args}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if m.ScanMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.ScanMock.defaultExpectation.Counter, 1)
		want := m.ScanMock.defaultExpectation.params
		got := DatabaseMockScanParams{ctx, scanner, sql, args}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("DatabaseMock.Scan got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.ScanMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the DatabaseMock.Scan")
		}
		return (*results).err
	}
	if m.funcScan != nil {
		return m.funcScan(ctx, scanner, sql, args...)
	}
	m.t.Fatalf("Unexpected call to DatabaseMock.Scan. %v %v %v %v", ctx, scanner, sql, args)
	return
}

// ScanAfterCounter returns a count of finished DatabaseMock.Scan invocations
func (m *DatabaseMock) ScanAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterScanCounter)
}

// ScanBeforeCounter returns a count of DatabaseMock.Scan invocations
func (m *DatabaseMock) ScanBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeScanCounter)
}

// MinimockScanDone returns true if the count of the Scan invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockScanDone() bool {
	for _, e := range m.ScanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScan != nil && mm_atomic.LoadUint64(&m.afterScanCounter) < 1 {
		return false
	}
	return true
}

// MinimockScanInspect logs each unmet expectation
func (m *DatabaseMock) MinimockScanInspect() {
	for _, e := range m.ScanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.Scan with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanCounter) < 1 {
		if m.ScanMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.Scan")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.Scan with params: %#v", *m.ScanMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScan != nil && mm_atomic.LoadUint64(&m.afterScanCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.Scan")
	}
}

type mDatabaseMockScanOne struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockScanOneExpectation
	expectations       []*DatabaseMockScanOneExpectation
}

// DatabaseMockScanOneExpectation specifies expectation struct of the Database.ScanOne
type DatabaseMockScanOneExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockScanOneParams
	results *DatabaseMockScanOneResults
	Counter uint64
}

// DatabaseMockScanOneParams contains parameters of the Database.ScanOne
type DatabaseMockScanOneParams struct {
	ctx     context.Context
	scanner RowScanner
	sql     string
	args    []interface{}
}

// DatabaseMockScanOneResults contains results of the Database.ScanOne
type DatabaseMockScanOneResults struct {
	err error
}

// Expect sets up expected params for Database.ScanOne
func (m *mDatabaseMockScanOne) Expect(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) *mDatabaseMockScanOne {
	if m.mock.funcScanOne != nil {
		m.mock.t.Fatalf("DatabaseMock.ScanOne mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockScanOneExpectation{}
	}

	m.defaultExpectation.params = &DatabaseMockScanOneParams{ctx, scanner, sql, args}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by Database.ScanOne
func (m *mDatabaseMockScanOne) Return(err error) *DatabaseMock {
	if m.mock.funcScanOne != nil {
		m.mock.t.Fatalf("DatabaseMock.ScanOne mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockScanOneExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &DatabaseMockScanOneResults{err}
	return m.mock
}

//Set uses given function f to mock the Database.ScanOne method
func (m *mDatabaseMockScanOne) Set(f func(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) (err error)) *DatabaseMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Database.ScanOne method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Database.ScanOne method")
	}

	m.mock.funcScanOne = f
	return m.mock
}

// When sets expectation for the Database.ScanOne which will trigger the result defined by the following
// Then helper
func (m *mDatabaseMockScanOne) When(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) *DatabaseMockScanOneExpectation {
	if m.mock.funcScanOne != nil {
		m.mock.t.Fatalf("DatabaseMock.ScanOne mock is already set by Set")
	}

	expectation := &DatabaseMockScanOneExpectation{
		mock:   m.mock,
		params: &DatabaseMockScanOneParams{ctx, scanner, sql, args},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up Database.ScanOne return parameters for the expectation previously defined by the When method
func (e *DatabaseMockScanOneExpectation) Then(err error) *DatabaseMock {
	e.results = &DatabaseMockScanOneResults{err}
	return e.mock
}

// ScanOne implements Database
func (m *DatabaseMock) ScanOne(ctx context.Context, scanner RowScanner, sql string, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&m.beforeScanOneCounter, 1)
	defer mm_atomic.AddUint64(&m.afterScanOneCounter, 1)

	for _, e := range m.ScanOneMock.expectations {
		if minimock.Equal(*e.params, DatabaseMockScanOneParams{ctx, scanner, sql, args}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if m.ScanOneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.ScanOneMock.defaultExpectation.Counter, 1)
		want := m.ScanOneMock.defaultExpectation.params
		got := DatabaseMockScanOneParams{ctx, scanner, sql, args}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("DatabaseMock.ScanOne got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.ScanOneMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the DatabaseMock.ScanOne")
		}
		return (*results).err
	}
	if m.funcScanOne != nil {
		return m.funcScanOne(ctx, scanner, sql, args...)
	}
	m.t.Fatalf("Unexpected call to DatabaseMock.ScanOne. %v %v %v %v", ctx, scanner, sql, args)
	return
}

// ScanOneAfterCounter returns a count of finished DatabaseMock.ScanOne invocations
func (m *DatabaseMock) ScanOneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterScanOneCounter)
}

// ScanOneBeforeCounter returns a count of DatabaseMock.ScanOne invocations
func (m *DatabaseMock) ScanOneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeScanOneCounter)
}

// MinimockScanOneDone returns true if the count of the ScanOne invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockScanOneDone() bool {
	for _, e := range m.ScanOneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanOneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanOneCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanOne != nil && mm_atomic.LoadUint64(&m.afterScanOneCounter) < 1 {
		return false
	}
	return true
}

// MinimockScanOneInspect logs each unmet expectation
func (m *DatabaseMock) MinimockScanOneInspect() {
	for _, e := range m.ScanOneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.ScanOne with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanOneMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanOneCounter) < 1 {
		if m.ScanOneMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.ScanOne")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.ScanOne with params: %#v", *m.ScanOneMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanOne != nil && mm_atomic.LoadUint64(&m.afterScanOneCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.ScanOne")
	}
}

type mDatabaseMockTransaction struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockTransactionExpectation
	expectations       []*DatabaseMockTransactionExpectation
}

// DatabaseMockTransactionExpectation specifies expectation struct of the Database.Transaction
type DatabaseMockTransactionExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockTransactionParams
	results *DatabaseMockTransactionResults
	Counter uint64
}

// DatabaseMockTransactionParams contains parameters of the Database.Transaction
type DatabaseMockTransactionParams struct {
	ctx  context.Context
	work func(Transaction) error
}

// DatabaseMockTransactionResults contains results of the Database.Transaction
type DatabaseMockTransactionResults struct {
	err error
}

// Expect sets up expected params for Database.Transaction
func (m *mDatabaseMockTransaction) Expect(ctx context.Context, work func(Transaction) error) *mDatabaseMockTransaction {
	if m.mock.funcTransaction != nil {
		m.mock.t.Fatalf("DatabaseMock.Transaction mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockTransactionExpectation{}
	}

	m.defaultExpectation.params = &DatabaseMockTransactionParams{ctx, work}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by Database.Transaction
func (m *mDatabaseMockTransaction) Return(err error) *DatabaseMock {
	if m.mock.funcTransaction != nil {
		m.mock.t.Fatalf("DatabaseMock.Transaction mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockTransactionExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &DatabaseMockTransactionResults{err}
	return m.mock
}

//Set uses given function f to mock the Database.Transaction method
func (m *mDatabaseMockTransaction) Set(f func(ctx context.Context, work func(Transaction) error) (err error)) *DatabaseMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Database.Transaction method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Database.Transaction method")
	}

	m.mock.funcTransaction = f
	return m.mock
}

// When sets expectation for the Database.Transaction which will trigger the result defined by the following
// Then helper
func (m *mDatabaseMockTransaction) When(ctx context.Context, work func(Transaction) error) *DatabaseMockTransactionExpectation {
	if m.mock.funcTransaction != nil {
		m.mock.t.Fatalf("DatabaseMock.Transaction mock is already set by Set")
	}

	expectation := &DatabaseMockTransactionExpectation{
		mock:   m.mock,
		params: &DatabaseMockTransactionParams{ctx, work},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up Database.Transaction return parameters for the expectation previously defined by the When method
func (e *DatabaseMockTransactionExpectation) Then(err error) *DatabaseMock {
	e.results = &DatabaseMockTransactionResults{err}
	return e.mock
}

// Transaction implements Database
func (m *DatabaseMock) Transaction(ctx context.Context, work func(Transaction) error) (err error) {
	mm_atomic.AddUint64(&m.beforeTransactionCounter, 1)
	defer mm_atomic.AddUint64(&m.afterTransactionCounter, 1)

	for _, e := range m.TransactionMock.expectations {
		if minimock.Equal(*e.params, DatabaseMockTransactionParams{ctx, work}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if m.TransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.TransactionMock.defaultExpectation.Counter, 1)
		want := m.TransactionMock.defaultExpectation.params
		got := DatabaseMockTransactionParams{ctx, work}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("DatabaseMock.Transaction got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.TransactionMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the DatabaseMock.Transaction")
		}
		return (*results).err
	}
	if m.funcTransaction != nil {
		return m.funcTransaction(ctx, work)
	}
	m.t.Fatalf("Unexpected call to DatabaseMock.Transaction. %v %v", ctx, work)
	return
}

// TransactionAfterCounter returns a count of finished DatabaseMock.Transaction invocations
func (m *DatabaseMock) TransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterTransactionCounter)
}

// TransactionBeforeCounter returns a count of DatabaseMock.Transaction invocations
func (m *DatabaseMock) TransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeTransactionCounter)
}

// MinimockTransactionDone returns true if the count of the Transaction invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockTransactionDone() bool {
	for _, e := range m.TransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TransactionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTransactionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTransaction != nil && mm_atomic.LoadUint64(&m.afterTransactionCounter) < 1 {
		return false
	}
	return true
}

// MinimockTransactionInspect logs each unmet expectation
func (m *DatabaseMock) MinimockTransactionInspect() {
	for _, e := range m.TransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.Transaction with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TransactionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTransactionCounter) < 1 {
		if m.TransactionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.Transaction")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.Transaction with params: %#v", *m.TransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTransaction != nil && mm_atomic.LoadUint64(&m.afterTransactionCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.Transaction")
	}
}

type mDatabaseMockUpdate struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockUpdateExpectation
	expectations       []*DatabaseMockUpdateExpectation
}

// DatabaseMockUpdateExpectation specifies expectation struct of the Database.Update
type DatabaseMockUpdateExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockUpdateParams
	results *DatabaseMockUpdateResults
	Counter uint64
}

// DatabaseMockUpdateParams contains parameters of the Database.Update
type DatabaseMockUpdateParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// DatabaseMockUpdateResults contains results of the Database.Update
type DatabaseMockUpdateResults struct {
	r1  sql.Result
	err error
}

// Expect sets up expected params for Database.Update
func (m *mDatabaseMockUpdate) Expect(ctx context.Context, sql string, args ...interface{}) *mDatabaseMockUpdate {
	if m.mock.funcUpdate != nil {
		m.mock.t.Fatalf("DatabaseMock.Update mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockUpdateExpectation{}
	}

	m.defaultExpectation.params = &DatabaseMockUpdateParams{ctx, sql, args}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by Database.Update
func (m *mDatabaseMockUpdate) Return(r1 sql.Result, err error) *DatabaseMock {
	if m.mock.funcUpdate != nil {
		m.mock.t.Fatalf("DatabaseMock.Update mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockUpdateExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &DatabaseMockUpdateResults{r1, err}
	return m.mock
}

//Set uses given function f to mock the Database.Update method
func (m *mDatabaseMockUpdate) Set(f func(ctx context.Context, sql string, args ...interface{}) (r1 sql.Result, err error)) *DatabaseMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Database.Update method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Database.Update method")
	}

	m.mock.funcUpdate = f
	return m.mock
}

// When sets expectation for the Database.Update which will trigger the result defined by the following
// Then helper
func (m *mDatabaseMockUpdate) When(ctx context.Context, sql string, args ...interface{}) *DatabaseMockUpdateExpectation {
	if m.mock.funcUpdate != nil {
		m.mock.t.Fatalf("DatabaseMock.Update mock is already set by Set")
	}

	expectation := &DatabaseMockUpdateExpectation{
		mock:   m.mock,
		params: &DatabaseMockUpdateParams{ctx, sql, args},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up Database.Update return parameters for the expectation previously defined by the When method
func (e *DatabaseMockUpdateExpectation) Then(r1 sql.Result, err error) *DatabaseMock {
	e.results = &DatabaseMockUpdateResults{r1, err}
	return e.mock
}

// Update implements Database
func (m *DatabaseMock) Update(ctx context.Context, sql string, args ...interface{}) (r1 sql.Result, err error) {
	mm_atomic.AddUint64(&m.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&m.afterUpdateCounter, 1)

	for _, e := range m.UpdateMock.expectations {
		if minimock.Equal(*e.params, DatabaseMockUpdateParams{ctx, sql, args}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if m.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.UpdateMock.defaultExpectation.Counter, 1)
		want := m.UpdateMock.defaultExpectation.params
		got := DatabaseMockUpdateParams{ctx, sql, args}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("DatabaseMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.UpdateMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the DatabaseMock.Update")
		}
		return (*results).r1, (*results).err
	}
	if m.funcUpdate != nil {
		return m.funcUpdate(ctx, sql, args...)
	}
	m.t.Fatalf("Unexpected call to DatabaseMock.Update. %v %v %v", ctx, sql, args)
	return
}

// UpdateAfterCounter returns a count of finished DatabaseMock.Update invocations
func (m *DatabaseMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of DatabaseMock.Update invocations
func (m *DatabaseMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeUpdateCounter)
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *DatabaseMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.Update")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.Update")
	}
}

type mDatabaseMockUpdateAndGetLastInsertID struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockUpdateAndGetLastInsertIDExpectation
	expectations       []*DatabaseMockUpdateAndGetLastInsertIDExpectation
}

// DatabaseMockUpdateAndGetLastInsertIDExpectation specifies expectation struct of the Database.UpdateAndGetLastInsertID
type DatabaseMockUpdateAndGetLastInsertIDExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockUpdateAndGetLastInsertIDParams
	results *DatabaseMockUpdateAndGetLastInsertIDResults
	Counter uint64
}

// DatabaseMockUpdateAndGetLastInsertIDParams contains parameters of the Database.UpdateAndGetLastInsertID
type DatabaseMockUpdateAndGetLastInsertIDParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// DatabaseMockUpdateAndGetLastInsertIDResults contains results of the Database.UpdateAndGetLastInsertID
type DatabaseMockUpdateAndGetLastInsertIDResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Database.UpdateAndGetLastInsertID
func (m *mDatabaseMockUpdateAndGetLastInsertID) Expect(ctx context.Context, sql string, args ...interface{}) *mDatabaseMockUpdateAndGetLastInsertID {
	if m.mock.funcUpdateAndGetLastInsertID != nil {
		m.mock.t.Fatalf("DatabaseMock.UpdateAndGetLastInsertID mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockUpdateAndGetLastInsertIDExpectation{}
	}

	m.defaultExpectation.params = &DatabaseMockUpdateAndGetLastInsertIDParams{ctx, sql, args}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by Database.UpdateAndGetLastInsertID
func (m *mDatabaseMockUpdateAndGetLastInsertID) Return(i1 int64, err error) *DatabaseMock {
	if m.mock.funcUpdateAndGetLastInsertID != nil {
		m.mock.t.Fatalf("DatabaseMock.UpdateAndGetLastInsertID mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockUpdateAndGetLastInsertIDExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &DatabaseMockUpdateAndGetLastInsertIDResults{i1, err}
	return m.mock
}

//Set uses given function f to mock the Database.UpdateAndGetLastInsertID method
func (m *mDatabaseMockUpdateAndGetLastInsertID) Set(f func(ctx context.Context, sql string, args ...interface{}) (i1 int64, err error)) *DatabaseMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Database.UpdateAndGetLastInsertID method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Database.UpdateAndGetLastInsertID method")
	}

	m.mock.funcUpdateAndGetLastInsertID = f
	return m.mock
}

// When sets expectation for the Database.UpdateAndGetLastInsertID which will trigger the result defined by the following
// Then helper
func (m *mDatabaseMockUpdateAndGetLastInsertID) When(ctx context.Context, sql string, args ...interface{}) *DatabaseMockUpdateAndGetLastInsertIDExpectation {
	if m.mock.funcUpdateAndGetLastInsertID != nil {
		m.mock.t.Fatalf("DatabaseMock.UpdateAndGetLastInsertID mock is already set by Set")
	}

	expectation := &DatabaseMockUpdateAndGetLastInsertIDExpectation{
		mock:   m.mock,
		params: &DatabaseMockUpdateAndGetLastInsertIDParams{ctx, sql, args},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up Database.UpdateAndGetLastInsertID return parameters for the expectation previously defined by the When method
func (e *DatabaseMockUpdateAndGetLastInsertIDExpectation) Then(i1 int64, err error) *DatabaseMock {
	e.results = &DatabaseMockUpdateAndGetLastInsertIDResults{i1, err}
	return e.mock
}

// UpdateAndGetLastInsertID implements Database
func (m *DatabaseMock) UpdateAndGetLastInsertID(ctx context.Context, sql string, args ...interface{}) (i1 int64, err error) {
	mm_atomic.AddUint64(&m.beforeUpdateAndGetLastInsertIDCounter, 1)
	defer mm_atomic.AddUint64(&m.afterUpdateAndGetLastInsertIDCounter, 1)

	for _, e := range m.UpdateAndGetLastInsertIDMock.expectations {
		if minimock.Equal(*e.params, DatabaseMockUpdateAndGetLastInsertIDParams{ctx, sql, args}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if m.UpdateAndGetLastInsertIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.UpdateAndGetLastInsertIDMock.defaultExpectation.Counter, 1)
		want := m.UpdateAndGetLastInsertIDMock.defaultExpectation.params
		got := DatabaseMockUpdateAndGetLastInsertIDParams{ctx, sql, args}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("DatabaseMock.UpdateAndGetLastInsertID got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.UpdateAndGetLastInsertIDMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the DatabaseMock.UpdateAndGetLastInsertID")
		}
		return (*results).i1, (*results).err
	}
	if m.funcUpdateAndGetLastInsertID != nil {
		return m.funcUpdateAndGetLastInsertID(ctx, sql, args...)
	}
	m.t.Fatalf("Unexpected call to DatabaseMock.UpdateAndGetLastInsertID. %v %v %v", ctx, sql, args)
	return
}

// UpdateAndGetLastInsertIDAfterCounter returns a count of finished DatabaseMock.UpdateAndGetLastInsertID invocations
func (m *DatabaseMock) UpdateAndGetLastInsertIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterUpdateAndGetLastInsertIDCounter)
}

// UpdateAndGetLastInsertIDBeforeCounter returns a count of DatabaseMock.UpdateAndGetLastInsertID invocations
func (m *DatabaseMock) UpdateAndGetLastInsertIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeUpdateAndGetLastInsertIDCounter)
}

// MinimockUpdateAndGetLastInsertIDDone returns true if the count of the UpdateAndGetLastInsertID invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockUpdateAndGetLastInsertIDDone() bool {
	for _, e := range m.UpdateAndGetLastInsertIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAndGetLastInsertIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetLastInsertIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAndGetLastInsertID != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetLastInsertIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateAndGetLastInsertIDInspect logs each unmet expectation
func (m *DatabaseMock) MinimockUpdateAndGetLastInsertIDInspect() {
	for _, e := range m.UpdateAndGetLastInsertIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.UpdateAndGetLastInsertID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAndGetLastInsertIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetLastInsertIDCounter) < 1 {
		if m.UpdateAndGetLastInsertIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.UpdateAndGetLastInsertID")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.UpdateAndGetLastInsertID with params: %#v", *m.UpdateAndGetLastInsertIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAndGetLastInsertID != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetLastInsertIDCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.UpdateAndGetLastInsertID")
	}
}

type mDatabaseMockUpdateAndGetRowsAffected struct {
	mock               *DatabaseMock
	defaultExpectation *DatabaseMockUpdateAndGetRowsAffectedExpectation
	expectations       []*DatabaseMockUpdateAndGetRowsAffectedExpectation
}

// DatabaseMockUpdateAndGetRowsAffectedExpectation specifies expectation struct of the Database.UpdateAndGetRowsAffected
type DatabaseMockUpdateAndGetRowsAffectedExpectation struct {
	mock    *DatabaseMock
	params  *DatabaseMockUpdateAndGetRowsAffectedParams
	results *DatabaseMockUpdateAndGetRowsAffectedResults
	Counter uint64
}

// DatabaseMockUpdateAndGetRowsAffectedParams contains parameters of the Database.UpdateAndGetRowsAffected
type DatabaseMockUpdateAndGetRowsAffectedParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// DatabaseMockUpdateAndGetRowsAffectedResults contains results of the Database.UpdateAndGetRowsAffected
type DatabaseMockUpdateAndGetRowsAffectedResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Database.UpdateAndGetRowsAffected
func (m *mDatabaseMockUpdateAndGetRowsAffected) Expect(ctx context.Context, sql string, args ...interface{}) *mDatabaseMockUpdateAndGetRowsAffected {
	if m.mock.funcUpdateAndGetRowsAffected != nil {
		m.mock.t.Fatalf("DatabaseMock.UpdateAndGetRowsAffected mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockUpdateAndGetRowsAffectedExpectation{}
	}

	m.defaultExpectation.params = &DatabaseMockUpdateAndGetRowsAffectedParams{ctx, sql, args}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by Database.UpdateAndGetRowsAffected
func (m *mDatabaseMockUpdateAndGetRowsAffected) Return(i1 int64, err error) *DatabaseMock {
	if m.mock.funcUpdateAndGetRowsAffected != nil {
		m.mock.t.Fatalf("DatabaseMock.UpdateAndGetRowsAffected mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &DatabaseMockUpdateAndGetRowsAffectedExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &DatabaseMockUpdateAndGetRowsAffectedResults{i1, err}
	return m.mock
}

//Set uses given function f to mock the Database.UpdateAndGetRowsAffected method
func (m *mDatabaseMockUpdateAndGetRowsAffected) Set(f func(ctx context.Context, sql string, args ...interface{}) (i1 int64, err error)) *DatabaseMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the Database.UpdateAndGetRowsAffected method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the Database.UpdateAndGetRowsAffected method")
	}

	m.mock.funcUpdateAndGetRowsAffected = f
	return m.mock
}

// When sets expectation for the Database.UpdateAndGetRowsAffected which will trigger the result defined by the following
// Then helper
func (m *mDatabaseMockUpdateAndGetRowsAffected) When(ctx context.Context, sql string, args ...interface{}) *DatabaseMockUpdateAndGetRowsAffectedExpectation {
	if m.mock.funcUpdateAndGetRowsAffected != nil {
		m.mock.t.Fatalf("DatabaseMock.UpdateAndGetRowsAffected mock is already set by Set")
	}

	expectation := &DatabaseMockUpdateAndGetRowsAffectedExpectation{
		mock:   m.mock,
		params: &DatabaseMockUpdateAndGetRowsAffectedParams{ctx, sql, args},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up Database.UpdateAndGetRowsAffected return parameters for the expectation previously defined by the When method
func (e *DatabaseMockUpdateAndGetRowsAffectedExpectation) Then(i1 int64, err error) *DatabaseMock {
	e.results = &DatabaseMockUpdateAndGetRowsAffectedResults{i1, err}
	return e.mock
}

// UpdateAndGetRowsAffected implements Database
func (m *DatabaseMock) UpdateAndGetRowsAffected(ctx context.Context, sql string, args ...interface{}) (i1 int64, err error) {
	mm_atomic.AddUint64(&m.beforeUpdateAndGetRowsAffectedCounter, 1)
	defer mm_atomic.AddUint64(&m.afterUpdateAndGetRowsAffectedCounter, 1)

	for _, e := range m.UpdateAndGetRowsAffectedMock.expectations {
		if minimock.Equal(*e.params, DatabaseMockUpdateAndGetRowsAffectedParams{ctx, sql, args}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if m.UpdateAndGetRowsAffectedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.UpdateAndGetRowsAffectedMock.defaultExpectation.Counter, 1)
		want := m.UpdateAndGetRowsAffectedMock.defaultExpectation.params
		got := DatabaseMockUpdateAndGetRowsAffectedParams{ctx, sql, args}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("DatabaseMock.UpdateAndGetRowsAffected got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.UpdateAndGetRowsAffectedMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the DatabaseMock.UpdateAndGetRowsAffected")
		}
		return (*results).i1, (*results).err
	}
	if m.funcUpdateAndGetRowsAffected != nil {
		return m.funcUpdateAndGetRowsAffected(ctx, sql, args...)
	}
	m.t.Fatalf("Unexpected call to DatabaseMock.UpdateAndGetRowsAffected. %v %v %v", ctx, sql, args)
	return
}

// UpdateAndGetRowsAffectedAfterCounter returns a count of finished DatabaseMock.UpdateAndGetRowsAffected invocations
func (m *DatabaseMock) UpdateAndGetRowsAffectedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterUpdateAndGetRowsAffectedCounter)
}

// UpdateAndGetRowsAffectedBeforeCounter returns a count of DatabaseMock.UpdateAndGetRowsAffected invocations
func (m *DatabaseMock) UpdateAndGetRowsAffectedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeUpdateAndGetRowsAffectedCounter)
}

// MinimockUpdateAndGetRowsAffectedDone returns true if the count of the UpdateAndGetRowsAffected invocations corresponds
// the number of defined expectations
func (m *DatabaseMock) MinimockUpdateAndGetRowsAffectedDone() bool {
	for _, e := range m.UpdateAndGetRowsAffectedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAndGetRowsAffectedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetRowsAffectedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAndGetRowsAffected != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetRowsAffectedCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateAndGetRowsAffectedInspect logs each unmet expectation
func (m *DatabaseMock) MinimockUpdateAndGetRowsAffectedInspect() {
	for _, e := range m.UpdateAndGetRowsAffectedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DatabaseMock.UpdateAndGetRowsAffected with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAndGetRowsAffectedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetRowsAffectedCounter) < 1 {
		if m.UpdateAndGetRowsAffectedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DatabaseMock.UpdateAndGetRowsAffected")
		} else {
			m.t.Errorf("Expected call to DatabaseMock.UpdateAndGetRowsAffected with params: %#v", *m.UpdateAndGetRowsAffectedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAndGetRowsAffected != nil && mm_atomic.LoadUint64(&m.afterUpdateAndGetRowsAffectedCounter) < 1 {
		m.t.Error("Expected call to DatabaseMock.UpdateAndGetRowsAffected")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DatabaseMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCloseInspect()

		m.MinimockPreparedInspect()

		m.MinimockScanInspect()

		m.MinimockScanOneInspect()

		m.MinimockTransactionInspect()

		m.MinimockUpdateInspect()

		m.MinimockUpdateAndGetLastInsertIDInspect()

		m.MinimockUpdateAndGetRowsAffectedInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DatabaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DatabaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockPreparedDone() &&
		m.MinimockScanDone() &&
		m.MinimockScanOneDone() &&
		m.MinimockTransactionDone() &&
		m.MinimockUpdateDone() &&
		m.MinimockUpdateAndGetLastInsertIDDone() &&
		m.MinimockUpdateAndGetRowsAffectedDone()
}
