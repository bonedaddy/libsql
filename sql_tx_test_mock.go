package libsql

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"database/sql"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SqlTxMock implements sqlTx
type SqlTxMock struct {
	t minimock.Tester

	funcCommit          func() (err error)
	inspectFuncCommit   func()
	afterCommitCounter  uint64
	beforeCommitCounter uint64
	CommitMock          mSqlTxMockCommit

	funcExec          func(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error)
	inspectFuncExec   func(ctx context.Context, query string, args ...interface{})
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mSqlTxMockExec

	funcPrepare          func(ctx context.Context, query string) (s1 sqlStmt, err error)
	inspectFuncPrepare   func(ctx context.Context, query string)
	afterPrepareCounter  uint64
	beforePrepareCounter uint64
	PrepareMock          mSqlTxMockPrepare

	funcQuery          func(ctx context.Context, query string, args ...interface{}) (s1 sqlRows, err error)
	inspectFuncQuery   func(ctx context.Context, query string, args ...interface{})
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mSqlTxMockQuery

	funcRollback          func() (err error)
	inspectFuncRollback   func()
	afterRollbackCounter  uint64
	beforeRollbackCounter uint64
	RollbackMock          mSqlTxMockRollback
}

// NewSqlTxMock returns a mock for sqlTx
func NewSqlTxMock(t minimock.Tester) *SqlTxMock {
	m := &SqlTxMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CommitMock = mSqlTxMockCommit{mock: m}

	m.ExecMock = mSqlTxMockExec{mock: m}
	m.ExecMock.callArgs = []*SqlTxMockExecParams{}

	m.PrepareMock = mSqlTxMockPrepare{mock: m}
	m.PrepareMock.callArgs = []*SqlTxMockPrepareParams{}

	m.QueryMock = mSqlTxMockQuery{mock: m}
	m.QueryMock.callArgs = []*SqlTxMockQueryParams{}

	m.RollbackMock = mSqlTxMockRollback{mock: m}

	return m
}

type mSqlTxMockCommit struct {
	mock               *SqlTxMock
	defaultExpectation *SqlTxMockCommitExpectation
	expectations       []*SqlTxMockCommitExpectation
}

// SqlTxMockCommitExpectation specifies expectation struct of the sqlTx.Commit
type SqlTxMockCommitExpectation struct {
	mock *SqlTxMock

	results *SqlTxMockCommitResults
	Counter uint64
}

// SqlTxMockCommitResults contains results of the sqlTx.Commit
type SqlTxMockCommitResults struct {
	err error
}

// Expect sets up expected params for sqlTx.Commit
func (mmCommit *mSqlTxMockCommit) Expect() *mSqlTxMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("SqlTxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &SqlTxMockCommitExpectation{}
	}

	return mmCommit
}

// Inspect accepts an inspector function that has same arguments as the sqlTx.Commit
func (mmCommit *mSqlTxMockCommit) Inspect(f func()) *mSqlTxMockCommit {
	if mmCommit.mock.inspectFuncCommit != nil {
		mmCommit.mock.t.Fatalf("Inspect function is already set for SqlTxMock.Commit")
	}

	mmCommit.mock.inspectFuncCommit = f

	return mmCommit
}

// Return sets up results that will be returned by sqlTx.Commit
func (mmCommit *mSqlTxMockCommit) Return(err error) *SqlTxMock {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("SqlTxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &SqlTxMockCommitExpectation{mock: mmCommit.mock}
	}
	mmCommit.defaultExpectation.results = &SqlTxMockCommitResults{err}
	return mmCommit.mock
}

//Set uses given function f to mock the sqlTx.Commit method
func (mmCommit *mSqlTxMockCommit) Set(f func() (err error)) *SqlTxMock {
	if mmCommit.defaultExpectation != nil {
		mmCommit.mock.t.Fatalf("Default expectation is already set for the sqlTx.Commit method")
	}

	if len(mmCommit.expectations) > 0 {
		mmCommit.mock.t.Fatalf("Some expectations are already set for the sqlTx.Commit method")
	}

	mmCommit.mock.funcCommit = f
	return mmCommit.mock
}

// Commit implements sqlTx
func (mmCommit *SqlTxMock) Commit() (err error) {
	mm_atomic.AddUint64(&mmCommit.beforeCommitCounter, 1)
	defer mm_atomic.AddUint64(&mmCommit.afterCommitCounter, 1)

	if mmCommit.inspectFuncCommit != nil {
		mmCommit.inspectFuncCommit()
	}

	if mmCommit.CommitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommit.CommitMock.defaultExpectation.Counter, 1)

		mm_results := mmCommit.CommitMock.defaultExpectation.results
		if mm_results == nil {
			mmCommit.t.Fatal("No results are set for the SqlTxMock.Commit")
		}
		return (*mm_results).err
	}
	if mmCommit.funcCommit != nil {
		return mmCommit.funcCommit()
	}
	mmCommit.t.Fatalf("Unexpected call to SqlTxMock.Commit.")
	return
}

// CommitAfterCounter returns a count of finished SqlTxMock.Commit invocations
func (mmCommit *SqlTxMock) CommitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.afterCommitCounter)
}

// CommitBeforeCounter returns a count of SqlTxMock.Commit invocations
func (mmCommit *SqlTxMock) CommitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.beforeCommitCounter)
}

// MinimockCommitDone returns true if the count of the Commit invocations corresponds
// the number of defined expectations
func (m *SqlTxMock) MinimockCommitDone() bool {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommitInspect logs each unmet expectation
func (m *SqlTxMock) MinimockCommitInspect() {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SqlTxMock.Commit")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		m.t.Error("Expected call to SqlTxMock.Commit")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		m.t.Error("Expected call to SqlTxMock.Commit")
	}
}

type mSqlTxMockExec struct {
	mock               *SqlTxMock
	defaultExpectation *SqlTxMockExecExpectation
	expectations       []*SqlTxMockExecExpectation

	callArgs []*SqlTxMockExecParams
	mutex    sync.RWMutex
}

// SqlTxMockExecExpectation specifies expectation struct of the sqlTx.Exec
type SqlTxMockExecExpectation struct {
	mock    *SqlTxMock
	params  *SqlTxMockExecParams
	results *SqlTxMockExecResults
	Counter uint64
}

// SqlTxMockExecParams contains parameters of the sqlTx.Exec
type SqlTxMockExecParams struct {
	ctx   context.Context
	query string
	args  []interface{}
}

// SqlTxMockExecResults contains results of the sqlTx.Exec
type SqlTxMockExecResults struct {
	r1  sql.Result
	err error
}

// Expect sets up expected params for sqlTx.Exec
func (mmExec *mSqlTxMockExec) Expect(ctx context.Context, query string, args ...interface{}) *mSqlTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("SqlTxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &SqlTxMockExecExpectation{}
	}

	mmExec.defaultExpectation.params = &SqlTxMockExecParams{ctx, query, args}
	for _, e := range mmExec.expectations {
		if minimock.Equal(e.params, mmExec.defaultExpectation.params) {
			mmExec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExec.defaultExpectation.params)
		}
	}

	return mmExec
}

// Inspect accepts an inspector function that has same arguments as the sqlTx.Exec
func (mmExec *mSqlTxMockExec) Inspect(f func(ctx context.Context, query string, args ...interface{})) *mSqlTxMockExec {
	if mmExec.mock.inspectFuncExec != nil {
		mmExec.mock.t.Fatalf("Inspect function is already set for SqlTxMock.Exec")
	}

	mmExec.mock.inspectFuncExec = f

	return mmExec
}

// Return sets up results that will be returned by sqlTx.Exec
func (mmExec *mSqlTxMockExec) Return(r1 sql.Result, err error) *SqlTxMock {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("SqlTxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &SqlTxMockExecExpectation{mock: mmExec.mock}
	}
	mmExec.defaultExpectation.results = &SqlTxMockExecResults{r1, err}
	return mmExec.mock
}

//Set uses given function f to mock the sqlTx.Exec method
func (mmExec *mSqlTxMockExec) Set(f func(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error)) *SqlTxMock {
	if mmExec.defaultExpectation != nil {
		mmExec.mock.t.Fatalf("Default expectation is already set for the sqlTx.Exec method")
	}

	if len(mmExec.expectations) > 0 {
		mmExec.mock.t.Fatalf("Some expectations are already set for the sqlTx.Exec method")
	}

	mmExec.mock.funcExec = f
	return mmExec.mock
}

// When sets expectation for the sqlTx.Exec which will trigger the result defined by the following
// Then helper
func (mmExec *mSqlTxMockExec) When(ctx context.Context, query string, args ...interface{}) *SqlTxMockExecExpectation {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("SqlTxMock.Exec mock is already set by Set")
	}

	expectation := &SqlTxMockExecExpectation{
		mock:   mmExec.mock,
		params: &SqlTxMockExecParams{ctx, query, args},
	}
	mmExec.expectations = append(mmExec.expectations, expectation)
	return expectation
}

// Then sets up sqlTx.Exec return parameters for the expectation previously defined by the When method
func (e *SqlTxMockExecExpectation) Then(r1 sql.Result, err error) *SqlTxMock {
	e.results = &SqlTxMockExecResults{r1, err}
	return e.mock
}

// Exec implements sqlTx
func (mmExec *SqlTxMock) Exec(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error) {
	mm_atomic.AddUint64(&mmExec.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&mmExec.afterExecCounter, 1)

	if mmExec.inspectFuncExec != nil {
		mmExec.inspectFuncExec(ctx, query, args...)
	}

	mm_params := &SqlTxMockExecParams{ctx, query, args}

	// Record call args
	mmExec.ExecMock.mutex.Lock()
	mmExec.ExecMock.callArgs = append(mmExec.ExecMock.callArgs, mm_params)
	mmExec.ExecMock.mutex.Unlock()

	for _, e := range mmExec.ExecMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmExec.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExec.ExecMock.defaultExpectation.Counter, 1)
		mm_want := mmExec.ExecMock.defaultExpectation.params
		mm_got := SqlTxMockExecParams{ctx, query, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExec.t.Errorf("SqlTxMock.Exec got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExec.ExecMock.defaultExpectation.results
		if mm_results == nil {
			mmExec.t.Fatal("No results are set for the SqlTxMock.Exec")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmExec.funcExec != nil {
		return mmExec.funcExec(ctx, query, args...)
	}
	mmExec.t.Fatalf("Unexpected call to SqlTxMock.Exec. %v %v %v", ctx, query, args)
	return
}

// ExecAfterCounter returns a count of finished SqlTxMock.Exec invocations
func (mmExec *SqlTxMock) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.afterExecCounter)
}

// ExecBeforeCounter returns a count of SqlTxMock.Exec invocations
func (mmExec *SqlTxMock) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.beforeExecCounter)
}

// Calls returns a list of arguments used in each call to SqlTxMock.Exec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExec *mSqlTxMockExec) Calls() []*SqlTxMockExecParams {
	mmExec.mutex.RLock()

	argCopy := make([]*SqlTxMockExecParams, len(mmExec.callArgs))
	copy(argCopy, mmExec.callArgs)

	mmExec.mutex.RUnlock()

	return argCopy
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *SqlTxMock) MinimockExecDone() bool {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	return true
}

// MinimockExecInspect logs each unmet expectation
func (m *SqlTxMock) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlTxMock.Exec with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SqlTxMock.Exec")
		} else {
			m.t.Errorf("Expected call to SqlTxMock.Exec with params: %#v", *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		m.t.Error("Expected call to SqlTxMock.Exec")
	}
}

type mSqlTxMockPrepare struct {
	mock               *SqlTxMock
	defaultExpectation *SqlTxMockPrepareExpectation
	expectations       []*SqlTxMockPrepareExpectation

	callArgs []*SqlTxMockPrepareParams
	mutex    sync.RWMutex
}

// SqlTxMockPrepareExpectation specifies expectation struct of the sqlTx.Prepare
type SqlTxMockPrepareExpectation struct {
	mock    *SqlTxMock
	params  *SqlTxMockPrepareParams
	results *SqlTxMockPrepareResults
	Counter uint64
}

// SqlTxMockPrepareParams contains parameters of the sqlTx.Prepare
type SqlTxMockPrepareParams struct {
	ctx   context.Context
	query string
}

// SqlTxMockPrepareResults contains results of the sqlTx.Prepare
type SqlTxMockPrepareResults struct {
	s1  sqlStmt
	err error
}

// Expect sets up expected params for sqlTx.Prepare
func (mmPrepare *mSqlTxMockPrepare) Expect(ctx context.Context, query string) *mSqlTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("SqlTxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &SqlTxMockPrepareExpectation{}
	}

	mmPrepare.defaultExpectation.params = &SqlTxMockPrepareParams{ctx, query}
	for _, e := range mmPrepare.expectations {
		if minimock.Equal(e.params, mmPrepare.defaultExpectation.params) {
			mmPrepare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrepare.defaultExpectation.params)
		}
	}

	return mmPrepare
}

// Inspect accepts an inspector function that has same arguments as the sqlTx.Prepare
func (mmPrepare *mSqlTxMockPrepare) Inspect(f func(ctx context.Context, query string)) *mSqlTxMockPrepare {
	if mmPrepare.mock.inspectFuncPrepare != nil {
		mmPrepare.mock.t.Fatalf("Inspect function is already set for SqlTxMock.Prepare")
	}

	mmPrepare.mock.inspectFuncPrepare = f

	return mmPrepare
}

// Return sets up results that will be returned by sqlTx.Prepare
func (mmPrepare *mSqlTxMockPrepare) Return(s1 sqlStmt, err error) *SqlTxMock {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("SqlTxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &SqlTxMockPrepareExpectation{mock: mmPrepare.mock}
	}
	mmPrepare.defaultExpectation.results = &SqlTxMockPrepareResults{s1, err}
	return mmPrepare.mock
}

//Set uses given function f to mock the sqlTx.Prepare method
func (mmPrepare *mSqlTxMockPrepare) Set(f func(ctx context.Context, query string) (s1 sqlStmt, err error)) *SqlTxMock {
	if mmPrepare.defaultExpectation != nil {
		mmPrepare.mock.t.Fatalf("Default expectation is already set for the sqlTx.Prepare method")
	}

	if len(mmPrepare.expectations) > 0 {
		mmPrepare.mock.t.Fatalf("Some expectations are already set for the sqlTx.Prepare method")
	}

	mmPrepare.mock.funcPrepare = f
	return mmPrepare.mock
}

// When sets expectation for the sqlTx.Prepare which will trigger the result defined by the following
// Then helper
func (mmPrepare *mSqlTxMockPrepare) When(ctx context.Context, query string) *SqlTxMockPrepareExpectation {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("SqlTxMock.Prepare mock is already set by Set")
	}

	expectation := &SqlTxMockPrepareExpectation{
		mock:   mmPrepare.mock,
		params: &SqlTxMockPrepareParams{ctx, query},
	}
	mmPrepare.expectations = append(mmPrepare.expectations, expectation)
	return expectation
}

// Then sets up sqlTx.Prepare return parameters for the expectation previously defined by the When method
func (e *SqlTxMockPrepareExpectation) Then(s1 sqlStmt, err error) *SqlTxMock {
	e.results = &SqlTxMockPrepareResults{s1, err}
	return e.mock
}

// Prepare implements sqlTx
func (mmPrepare *SqlTxMock) Prepare(ctx context.Context, query string) (s1 sqlStmt, err error) {
	mm_atomic.AddUint64(&mmPrepare.beforePrepareCounter, 1)
	defer mm_atomic.AddUint64(&mmPrepare.afterPrepareCounter, 1)

	if mmPrepare.inspectFuncPrepare != nil {
		mmPrepare.inspectFuncPrepare(ctx, query)
	}

	mm_params := &SqlTxMockPrepareParams{ctx, query}

	// Record call args
	mmPrepare.PrepareMock.mutex.Lock()
	mmPrepare.PrepareMock.callArgs = append(mmPrepare.PrepareMock.callArgs, mm_params)
	mmPrepare.PrepareMock.mutex.Unlock()

	for _, e := range mmPrepare.PrepareMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmPrepare.PrepareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrepare.PrepareMock.defaultExpectation.Counter, 1)
		mm_want := mmPrepare.PrepareMock.defaultExpectation.params
		mm_got := SqlTxMockPrepareParams{ctx, query}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrepare.t.Errorf("SqlTxMock.Prepare got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrepare.PrepareMock.defaultExpectation.results
		if mm_results == nil {
			mmPrepare.t.Fatal("No results are set for the SqlTxMock.Prepare")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmPrepare.funcPrepare != nil {
		return mmPrepare.funcPrepare(ctx, query)
	}
	mmPrepare.t.Fatalf("Unexpected call to SqlTxMock.Prepare. %v %v", ctx, query)
	return
}

// PrepareAfterCounter returns a count of finished SqlTxMock.Prepare invocations
func (mmPrepare *SqlTxMock) PrepareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.afterPrepareCounter)
}

// PrepareBeforeCounter returns a count of SqlTxMock.Prepare invocations
func (mmPrepare *SqlTxMock) PrepareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.beforePrepareCounter)
}

// Calls returns a list of arguments used in each call to SqlTxMock.Prepare.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrepare *mSqlTxMockPrepare) Calls() []*SqlTxMockPrepareParams {
	mmPrepare.mutex.RLock()

	argCopy := make([]*SqlTxMockPrepareParams, len(mmPrepare.callArgs))
	copy(argCopy, mmPrepare.callArgs)

	mmPrepare.mutex.RUnlock()

	return argCopy
}

// MinimockPrepareDone returns true if the count of the Prepare invocations corresponds
// the number of defined expectations
func (m *SqlTxMock) MinimockPrepareDone() bool {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrepareInspect logs each unmet expectation
func (m *SqlTxMock) MinimockPrepareInspect() {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlTxMock.Prepare with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		if m.PrepareMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SqlTxMock.Prepare")
		} else {
			m.t.Errorf("Expected call to SqlTxMock.Prepare with params: %#v", *m.PrepareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		m.t.Error("Expected call to SqlTxMock.Prepare")
	}
}

type mSqlTxMockQuery struct {
	mock               *SqlTxMock
	defaultExpectation *SqlTxMockQueryExpectation
	expectations       []*SqlTxMockQueryExpectation

	callArgs []*SqlTxMockQueryParams
	mutex    sync.RWMutex
}

// SqlTxMockQueryExpectation specifies expectation struct of the sqlTx.Query
type SqlTxMockQueryExpectation struct {
	mock    *SqlTxMock
	params  *SqlTxMockQueryParams
	results *SqlTxMockQueryResults
	Counter uint64
}

// SqlTxMockQueryParams contains parameters of the sqlTx.Query
type SqlTxMockQueryParams struct {
	ctx   context.Context
	query string
	args  []interface{}
}

// SqlTxMockQueryResults contains results of the sqlTx.Query
type SqlTxMockQueryResults struct {
	s1  sqlRows
	err error
}

// Expect sets up expected params for sqlTx.Query
func (mmQuery *mSqlTxMockQuery) Expect(ctx context.Context, query string, args ...interface{}) *mSqlTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("SqlTxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &SqlTxMockQueryExpectation{}
	}

	mmQuery.defaultExpectation.params = &SqlTxMockQueryParams{ctx, query, args}
	for _, e := range mmQuery.expectations {
		if minimock.Equal(e.params, mmQuery.defaultExpectation.params) {
			mmQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuery.defaultExpectation.params)
		}
	}

	return mmQuery
}

// Inspect accepts an inspector function that has same arguments as the sqlTx.Query
func (mmQuery *mSqlTxMockQuery) Inspect(f func(ctx context.Context, query string, args ...interface{})) *mSqlTxMockQuery {
	if mmQuery.mock.inspectFuncQuery != nil {
		mmQuery.mock.t.Fatalf("Inspect function is already set for SqlTxMock.Query")
	}

	mmQuery.mock.inspectFuncQuery = f

	return mmQuery
}

// Return sets up results that will be returned by sqlTx.Query
func (mmQuery *mSqlTxMockQuery) Return(s1 sqlRows, err error) *SqlTxMock {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("SqlTxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &SqlTxMockQueryExpectation{mock: mmQuery.mock}
	}
	mmQuery.defaultExpectation.results = &SqlTxMockQueryResults{s1, err}
	return mmQuery.mock
}

//Set uses given function f to mock the sqlTx.Query method
func (mmQuery *mSqlTxMockQuery) Set(f func(ctx context.Context, query string, args ...interface{}) (s1 sqlRows, err error)) *SqlTxMock {
	if mmQuery.defaultExpectation != nil {
		mmQuery.mock.t.Fatalf("Default expectation is already set for the sqlTx.Query method")
	}

	if len(mmQuery.expectations) > 0 {
		mmQuery.mock.t.Fatalf("Some expectations are already set for the sqlTx.Query method")
	}

	mmQuery.mock.funcQuery = f
	return mmQuery.mock
}

// When sets expectation for the sqlTx.Query which will trigger the result defined by the following
// Then helper
func (mmQuery *mSqlTxMockQuery) When(ctx context.Context, query string, args ...interface{}) *SqlTxMockQueryExpectation {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("SqlTxMock.Query mock is already set by Set")
	}

	expectation := &SqlTxMockQueryExpectation{
		mock:   mmQuery.mock,
		params: &SqlTxMockQueryParams{ctx, query, args},
	}
	mmQuery.expectations = append(mmQuery.expectations, expectation)
	return expectation
}

// Then sets up sqlTx.Query return parameters for the expectation previously defined by the When method
func (e *SqlTxMockQueryExpectation) Then(s1 sqlRows, err error) *SqlTxMock {
	e.results = &SqlTxMockQueryResults{s1, err}
	return e.mock
}

// Query implements sqlTx
func (mmQuery *SqlTxMock) Query(ctx context.Context, query string, args ...interface{}) (s1 sqlRows, err error) {
	mm_atomic.AddUint64(&mmQuery.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmQuery.afterQueryCounter, 1)

	if mmQuery.inspectFuncQuery != nil {
		mmQuery.inspectFuncQuery(ctx, query, args...)
	}

	mm_params := &SqlTxMockQueryParams{ctx, query, args}

	// Record call args
	mmQuery.QueryMock.mutex.Lock()
	mmQuery.QueryMock.callArgs = append(mmQuery.QueryMock.callArgs, mm_params)
	mmQuery.QueryMock.mutex.Unlock()

	for _, e := range mmQuery.QueryMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmQuery.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuery.QueryMock.defaultExpectation.Counter, 1)
		mm_want := mmQuery.QueryMock.defaultExpectation.params
		mm_got := SqlTxMockQueryParams{ctx, query, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuery.t.Errorf("SqlTxMock.Query got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuery.QueryMock.defaultExpectation.results
		if mm_results == nil {
			mmQuery.t.Fatal("No results are set for the SqlTxMock.Query")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmQuery.funcQuery != nil {
		return mmQuery.funcQuery(ctx, query, args...)
	}
	mmQuery.t.Fatalf("Unexpected call to SqlTxMock.Query. %v %v %v", ctx, query, args)
	return
}

// QueryAfterCounter returns a count of finished SqlTxMock.Query invocations
func (mmQuery *SqlTxMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.afterQueryCounter)
}

// QueryBeforeCounter returns a count of SqlTxMock.Query invocations
func (mmQuery *SqlTxMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.beforeQueryCounter)
}

// Calls returns a list of arguments used in each call to SqlTxMock.Query.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuery *mSqlTxMockQuery) Calls() []*SqlTxMockQueryParams {
	mmQuery.mutex.RLock()

	argCopy := make([]*SqlTxMockQueryParams, len(mmQuery.callArgs))
	copy(argCopy, mmQuery.callArgs)

	mmQuery.mutex.RUnlock()

	return argCopy
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *SqlTxMock) MinimockQueryDone() bool {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryInspect logs each unmet expectation
func (m *SqlTxMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlTxMock.Query with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SqlTxMock.Query")
		} else {
			m.t.Errorf("Expected call to SqlTxMock.Query with params: %#v", *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		m.t.Error("Expected call to SqlTxMock.Query")
	}
}

type mSqlTxMockRollback struct {
	mock               *SqlTxMock
	defaultExpectation *SqlTxMockRollbackExpectation
	expectations       []*SqlTxMockRollbackExpectation
}

// SqlTxMockRollbackExpectation specifies expectation struct of the sqlTx.Rollback
type SqlTxMockRollbackExpectation struct {
	mock *SqlTxMock

	results *SqlTxMockRollbackResults
	Counter uint64
}

// SqlTxMockRollbackResults contains results of the sqlTx.Rollback
type SqlTxMockRollbackResults struct {
	err error
}

// Expect sets up expected params for sqlTx.Rollback
func (mmRollback *mSqlTxMockRollback) Expect() *mSqlTxMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("SqlTxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &SqlTxMockRollbackExpectation{}
	}

	return mmRollback
}

// Inspect accepts an inspector function that has same arguments as the sqlTx.Rollback
func (mmRollback *mSqlTxMockRollback) Inspect(f func()) *mSqlTxMockRollback {
	if mmRollback.mock.inspectFuncRollback != nil {
		mmRollback.mock.t.Fatalf("Inspect function is already set for SqlTxMock.Rollback")
	}

	mmRollback.mock.inspectFuncRollback = f

	return mmRollback
}

// Return sets up results that will be returned by sqlTx.Rollback
func (mmRollback *mSqlTxMockRollback) Return(err error) *SqlTxMock {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("SqlTxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &SqlTxMockRollbackExpectation{mock: mmRollback.mock}
	}
	mmRollback.defaultExpectation.results = &SqlTxMockRollbackResults{err}
	return mmRollback.mock
}

//Set uses given function f to mock the sqlTx.Rollback method
func (mmRollback *mSqlTxMockRollback) Set(f func() (err error)) *SqlTxMock {
	if mmRollback.defaultExpectation != nil {
		mmRollback.mock.t.Fatalf("Default expectation is already set for the sqlTx.Rollback method")
	}

	if len(mmRollback.expectations) > 0 {
		mmRollback.mock.t.Fatalf("Some expectations are already set for the sqlTx.Rollback method")
	}

	mmRollback.mock.funcRollback = f
	return mmRollback.mock
}

// Rollback implements sqlTx
func (mmRollback *SqlTxMock) Rollback() (err error) {
	mm_atomic.AddUint64(&mmRollback.beforeRollbackCounter, 1)
	defer mm_atomic.AddUint64(&mmRollback.afterRollbackCounter, 1)

	if mmRollback.inspectFuncRollback != nil {
		mmRollback.inspectFuncRollback()
	}

	if mmRollback.RollbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRollback.RollbackMock.defaultExpectation.Counter, 1)

		mm_results := mmRollback.RollbackMock.defaultExpectation.results
		if mm_results == nil {
			mmRollback.t.Fatal("No results are set for the SqlTxMock.Rollback")
		}
		return (*mm_results).err
	}
	if mmRollback.funcRollback != nil {
		return mmRollback.funcRollback()
	}
	mmRollback.t.Fatalf("Unexpected call to SqlTxMock.Rollback.")
	return
}

// RollbackAfterCounter returns a count of finished SqlTxMock.Rollback invocations
func (mmRollback *SqlTxMock) RollbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.afterRollbackCounter)
}

// RollbackBeforeCounter returns a count of SqlTxMock.Rollback invocations
func (mmRollback *SqlTxMock) RollbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.beforeRollbackCounter)
}

// MinimockRollbackDone returns true if the count of the Rollback invocations corresponds
// the number of defined expectations
func (m *SqlTxMock) MinimockRollbackDone() bool {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		return false
	}
	return true
}

// MinimockRollbackInspect logs each unmet expectation
func (m *SqlTxMock) MinimockRollbackInspect() {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SqlTxMock.Rollback")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		m.t.Error("Expected call to SqlTxMock.Rollback")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		m.t.Error("Expected call to SqlTxMock.Rollback")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SqlTxMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCommitInspect()

		m.MinimockExecInspect()

		m.MinimockPrepareInspect()

		m.MinimockQueryInspect()

		m.MinimockRollbackInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SqlTxMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SqlTxMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCommitDone() &&
		m.MinimockExecDone() &&
		m.MinimockPrepareDone() &&
		m.MinimockQueryDone() &&
		m.MinimockRollbackDone()
}
