package libsql

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"database/sql"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// SqlTxMock implements sqlTx
type SqlTxMock struct {
	t minimock.Tester

	funcCommit          func() (err error)
	afterCommitCounter  uint64
	beforeCommitCounter uint64
	CommitMock          mSqlTxMockCommit

	funcExec          func(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error)
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mSqlTxMockExec

	funcPrepare          func(ctx context.Context, query string) (s1 sqlStmt, err error)
	afterPrepareCounter  uint64
	beforePrepareCounter uint64
	PrepareMock          mSqlTxMockPrepare

	funcQuery          func(ctx context.Context, query string, args ...interface{}) (s1 sqlRows, err error)
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mSqlTxMockQuery

	funcRollback          func() (err error)
	afterRollbackCounter  uint64
	beforeRollbackCounter uint64
	RollbackMock          mSqlTxMockRollback
}

// NewSqlTxMock returns a mock for sqlTx
func NewSqlTxMock(t minimock.Tester) *SqlTxMock {
	m := &SqlTxMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}
	m.CommitMock = mSqlTxMockCommit{mock: m}
	m.ExecMock = mSqlTxMockExec{mock: m}
	m.PrepareMock = mSqlTxMockPrepare{mock: m}
	m.QueryMock = mSqlTxMockQuery{mock: m}
	m.RollbackMock = mSqlTxMockRollback{mock: m}

	return m
}

type mSqlTxMockCommit struct {
	mock               *SqlTxMock
	defaultExpectation *SqlTxMockCommitExpectation
	expectations       []*SqlTxMockCommitExpectation
}

// SqlTxMockCommitExpectation specifies expectation struct of the sqlTx.Commit
type SqlTxMockCommitExpectation struct {
	mock *SqlTxMock

	results *SqlTxMockCommitResults
	Counter uint64
}

// SqlTxMockCommitResults contains results of the sqlTx.Commit
type SqlTxMockCommitResults struct {
	err error
}

// Expect sets up expected params for sqlTx.Commit
func (m *mSqlTxMockCommit) Expect() *mSqlTxMockCommit {
	if m.mock.funcCommit != nil {
		m.mock.t.Fatalf("SqlTxMock.Commit mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlTxMockCommitExpectation{}
	}

	return m
}

// Return sets up results that will be returned by sqlTx.Commit
func (m *mSqlTxMockCommit) Return(err error) *SqlTxMock {
	if m.mock.funcCommit != nil {
		m.mock.t.Fatalf("SqlTxMock.Commit mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlTxMockCommitExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &SqlTxMockCommitResults{err}
	return m.mock
}

//Set uses given function f to mock the sqlTx.Commit method
func (m *mSqlTxMockCommit) Set(f func() (err error)) *SqlTxMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the sqlTx.Commit method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the sqlTx.Commit method")
	}

	m.mock.funcCommit = f
	return m.mock
}

// Commit implements sqlTx
func (m *SqlTxMock) Commit() (err error) {
	mm_atomic.AddUint64(&m.beforeCommitCounter, 1)
	defer mm_atomic.AddUint64(&m.afterCommitCounter, 1)

	if m.CommitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.CommitMock.defaultExpectation.Counter, 1)

		results := m.CommitMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the SqlTxMock.Commit")
		}
		return (*results).err
	}
	if m.funcCommit != nil {
		return m.funcCommit()
	}
	m.t.Fatalf("Unexpected call to SqlTxMock.Commit.")
	return
}

// CommitAfterCounter returns a count of finished SqlTxMock.Commit invocations
func (m *SqlTxMock) CommitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterCommitCounter)
}

// CommitBeforeCounter returns a count of SqlTxMock.Commit invocations
func (m *SqlTxMock) CommitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeCommitCounter)
}

// MinimockCommitDone returns true if the count of the Commit invocations corresponds
// the number of defined expectations
func (m *SqlTxMock) MinimockCommitDone() bool {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommitInspect logs each unmet expectation
func (m *SqlTxMock) MinimockCommitInspect() {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SqlTxMock.Commit")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		m.t.Error("Expected call to SqlTxMock.Commit")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		m.t.Error("Expected call to SqlTxMock.Commit")
	}
}

type mSqlTxMockExec struct {
	mock               *SqlTxMock
	defaultExpectation *SqlTxMockExecExpectation
	expectations       []*SqlTxMockExecExpectation
}

// SqlTxMockExecExpectation specifies expectation struct of the sqlTx.Exec
type SqlTxMockExecExpectation struct {
	mock    *SqlTxMock
	params  *SqlTxMockExecParams
	results *SqlTxMockExecResults
	Counter uint64
}

// SqlTxMockExecParams contains parameters of the sqlTx.Exec
type SqlTxMockExecParams struct {
	ctx   context.Context
	query string
	args  []interface{}
}

// SqlTxMockExecResults contains results of the sqlTx.Exec
type SqlTxMockExecResults struct {
	r1  sql.Result
	err error
}

// Expect sets up expected params for sqlTx.Exec
func (m *mSqlTxMockExec) Expect(ctx context.Context, query string, args ...interface{}) *mSqlTxMockExec {
	if m.mock.funcExec != nil {
		m.mock.t.Fatalf("SqlTxMock.Exec mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlTxMockExecExpectation{}
	}

	m.defaultExpectation.params = &SqlTxMockExecParams{ctx, query, args}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by sqlTx.Exec
func (m *mSqlTxMockExec) Return(r1 sql.Result, err error) *SqlTxMock {
	if m.mock.funcExec != nil {
		m.mock.t.Fatalf("SqlTxMock.Exec mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlTxMockExecExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &SqlTxMockExecResults{r1, err}
	return m.mock
}

//Set uses given function f to mock the sqlTx.Exec method
func (m *mSqlTxMockExec) Set(f func(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error)) *SqlTxMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the sqlTx.Exec method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the sqlTx.Exec method")
	}

	m.mock.funcExec = f
	return m.mock
}

// When sets expectation for the sqlTx.Exec which will trigger the result defined by the following
// Then helper
func (m *mSqlTxMockExec) When(ctx context.Context, query string, args ...interface{}) *SqlTxMockExecExpectation {
	if m.mock.funcExec != nil {
		m.mock.t.Fatalf("SqlTxMock.Exec mock is already set by Set")
	}

	expectation := &SqlTxMockExecExpectation{
		mock:   m.mock,
		params: &SqlTxMockExecParams{ctx, query, args},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up sqlTx.Exec return parameters for the expectation previously defined by the When method
func (e *SqlTxMockExecExpectation) Then(r1 sql.Result, err error) *SqlTxMock {
	e.results = &SqlTxMockExecResults{r1, err}
	return e.mock
}

// Exec implements sqlTx
func (m *SqlTxMock) Exec(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error) {
	mm_atomic.AddUint64(&m.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&m.afterExecCounter, 1)

	for _, e := range m.ExecMock.expectations {
		if minimock.Equal(*e.params, SqlTxMockExecParams{ctx, query, args}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if m.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.ExecMock.defaultExpectation.Counter, 1)
		want := m.ExecMock.defaultExpectation.params
		got := SqlTxMockExecParams{ctx, query, args}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("SqlTxMock.Exec got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.ExecMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the SqlTxMock.Exec")
		}
		return (*results).r1, (*results).err
	}
	if m.funcExec != nil {
		return m.funcExec(ctx, query, args...)
	}
	m.t.Fatalf("Unexpected call to SqlTxMock.Exec. %v %v %v", ctx, query, args)
	return
}

// ExecAfterCounter returns a count of finished SqlTxMock.Exec invocations
func (m *SqlTxMock) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterExecCounter)
}

// ExecBeforeCounter returns a count of SqlTxMock.Exec invocations
func (m *SqlTxMock) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeExecCounter)
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *SqlTxMock) MinimockExecDone() bool {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	return true
}

// MinimockExecInspect logs each unmet expectation
func (m *SqlTxMock) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlTxMock.Exec with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SqlTxMock.Exec")
		} else {
			m.t.Errorf("Expected call to SqlTxMock.Exec with params: %#v", *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		m.t.Error("Expected call to SqlTxMock.Exec")
	}
}

type mSqlTxMockPrepare struct {
	mock               *SqlTxMock
	defaultExpectation *SqlTxMockPrepareExpectation
	expectations       []*SqlTxMockPrepareExpectation
}

// SqlTxMockPrepareExpectation specifies expectation struct of the sqlTx.Prepare
type SqlTxMockPrepareExpectation struct {
	mock    *SqlTxMock
	params  *SqlTxMockPrepareParams
	results *SqlTxMockPrepareResults
	Counter uint64
}

// SqlTxMockPrepareParams contains parameters of the sqlTx.Prepare
type SqlTxMockPrepareParams struct {
	ctx   context.Context
	query string
}

// SqlTxMockPrepareResults contains results of the sqlTx.Prepare
type SqlTxMockPrepareResults struct {
	s1  sqlStmt
	err error
}

// Expect sets up expected params for sqlTx.Prepare
func (m *mSqlTxMockPrepare) Expect(ctx context.Context, query string) *mSqlTxMockPrepare {
	if m.mock.funcPrepare != nil {
		m.mock.t.Fatalf("SqlTxMock.Prepare mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlTxMockPrepareExpectation{}
	}

	m.defaultExpectation.params = &SqlTxMockPrepareParams{ctx, query}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by sqlTx.Prepare
func (m *mSqlTxMockPrepare) Return(s1 sqlStmt, err error) *SqlTxMock {
	if m.mock.funcPrepare != nil {
		m.mock.t.Fatalf("SqlTxMock.Prepare mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlTxMockPrepareExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &SqlTxMockPrepareResults{s1, err}
	return m.mock
}

//Set uses given function f to mock the sqlTx.Prepare method
func (m *mSqlTxMockPrepare) Set(f func(ctx context.Context, query string) (s1 sqlStmt, err error)) *SqlTxMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the sqlTx.Prepare method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the sqlTx.Prepare method")
	}

	m.mock.funcPrepare = f
	return m.mock
}

// When sets expectation for the sqlTx.Prepare which will trigger the result defined by the following
// Then helper
func (m *mSqlTxMockPrepare) When(ctx context.Context, query string) *SqlTxMockPrepareExpectation {
	if m.mock.funcPrepare != nil {
		m.mock.t.Fatalf("SqlTxMock.Prepare mock is already set by Set")
	}

	expectation := &SqlTxMockPrepareExpectation{
		mock:   m.mock,
		params: &SqlTxMockPrepareParams{ctx, query},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up sqlTx.Prepare return parameters for the expectation previously defined by the When method
func (e *SqlTxMockPrepareExpectation) Then(s1 sqlStmt, err error) *SqlTxMock {
	e.results = &SqlTxMockPrepareResults{s1, err}
	return e.mock
}

// Prepare implements sqlTx
func (m *SqlTxMock) Prepare(ctx context.Context, query string) (s1 sqlStmt, err error) {
	mm_atomic.AddUint64(&m.beforePrepareCounter, 1)
	defer mm_atomic.AddUint64(&m.afterPrepareCounter, 1)

	for _, e := range m.PrepareMock.expectations {
		if minimock.Equal(*e.params, SqlTxMockPrepareParams{ctx, query}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if m.PrepareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.PrepareMock.defaultExpectation.Counter, 1)
		want := m.PrepareMock.defaultExpectation.params
		got := SqlTxMockPrepareParams{ctx, query}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("SqlTxMock.Prepare got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.PrepareMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the SqlTxMock.Prepare")
		}
		return (*results).s1, (*results).err
	}
	if m.funcPrepare != nil {
		return m.funcPrepare(ctx, query)
	}
	m.t.Fatalf("Unexpected call to SqlTxMock.Prepare. %v %v", ctx, query)
	return
}

// PrepareAfterCounter returns a count of finished SqlTxMock.Prepare invocations
func (m *SqlTxMock) PrepareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterPrepareCounter)
}

// PrepareBeforeCounter returns a count of SqlTxMock.Prepare invocations
func (m *SqlTxMock) PrepareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforePrepareCounter)
}

// MinimockPrepareDone returns true if the count of the Prepare invocations corresponds
// the number of defined expectations
func (m *SqlTxMock) MinimockPrepareDone() bool {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrepareInspect logs each unmet expectation
func (m *SqlTxMock) MinimockPrepareInspect() {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlTxMock.Prepare with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		if m.PrepareMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SqlTxMock.Prepare")
		} else {
			m.t.Errorf("Expected call to SqlTxMock.Prepare with params: %#v", *m.PrepareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		m.t.Error("Expected call to SqlTxMock.Prepare")
	}
}

type mSqlTxMockQuery struct {
	mock               *SqlTxMock
	defaultExpectation *SqlTxMockQueryExpectation
	expectations       []*SqlTxMockQueryExpectation
}

// SqlTxMockQueryExpectation specifies expectation struct of the sqlTx.Query
type SqlTxMockQueryExpectation struct {
	mock    *SqlTxMock
	params  *SqlTxMockQueryParams
	results *SqlTxMockQueryResults
	Counter uint64
}

// SqlTxMockQueryParams contains parameters of the sqlTx.Query
type SqlTxMockQueryParams struct {
	ctx   context.Context
	query string
	args  []interface{}
}

// SqlTxMockQueryResults contains results of the sqlTx.Query
type SqlTxMockQueryResults struct {
	s1  sqlRows
	err error
}

// Expect sets up expected params for sqlTx.Query
func (m *mSqlTxMockQuery) Expect(ctx context.Context, query string, args ...interface{}) *mSqlTxMockQuery {
	if m.mock.funcQuery != nil {
		m.mock.t.Fatalf("SqlTxMock.Query mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlTxMockQueryExpectation{}
	}

	m.defaultExpectation.params = &SqlTxMockQueryParams{ctx, query, args}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by sqlTx.Query
func (m *mSqlTxMockQuery) Return(s1 sqlRows, err error) *SqlTxMock {
	if m.mock.funcQuery != nil {
		m.mock.t.Fatalf("SqlTxMock.Query mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlTxMockQueryExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &SqlTxMockQueryResults{s1, err}
	return m.mock
}

//Set uses given function f to mock the sqlTx.Query method
func (m *mSqlTxMockQuery) Set(f func(ctx context.Context, query string, args ...interface{}) (s1 sqlRows, err error)) *SqlTxMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the sqlTx.Query method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the sqlTx.Query method")
	}

	m.mock.funcQuery = f
	return m.mock
}

// When sets expectation for the sqlTx.Query which will trigger the result defined by the following
// Then helper
func (m *mSqlTxMockQuery) When(ctx context.Context, query string, args ...interface{}) *SqlTxMockQueryExpectation {
	if m.mock.funcQuery != nil {
		m.mock.t.Fatalf("SqlTxMock.Query mock is already set by Set")
	}

	expectation := &SqlTxMockQueryExpectation{
		mock:   m.mock,
		params: &SqlTxMockQueryParams{ctx, query, args},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up sqlTx.Query return parameters for the expectation previously defined by the When method
func (e *SqlTxMockQueryExpectation) Then(s1 sqlRows, err error) *SqlTxMock {
	e.results = &SqlTxMockQueryResults{s1, err}
	return e.mock
}

// Query implements sqlTx
func (m *SqlTxMock) Query(ctx context.Context, query string, args ...interface{}) (s1 sqlRows, err error) {
	mm_atomic.AddUint64(&m.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&m.afterQueryCounter, 1)

	for _, e := range m.QueryMock.expectations {
		if minimock.Equal(*e.params, SqlTxMockQueryParams{ctx, query, args}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if m.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.QueryMock.defaultExpectation.Counter, 1)
		want := m.QueryMock.defaultExpectation.params
		got := SqlTxMockQueryParams{ctx, query, args}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("SqlTxMock.Query got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.QueryMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the SqlTxMock.Query")
		}
		return (*results).s1, (*results).err
	}
	if m.funcQuery != nil {
		return m.funcQuery(ctx, query, args...)
	}
	m.t.Fatalf("Unexpected call to SqlTxMock.Query. %v %v %v", ctx, query, args)
	return
}

// QueryAfterCounter returns a count of finished SqlTxMock.Query invocations
func (m *SqlTxMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterQueryCounter)
}

// QueryBeforeCounter returns a count of SqlTxMock.Query invocations
func (m *SqlTxMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeQueryCounter)
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *SqlTxMock) MinimockQueryDone() bool {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryInspect logs each unmet expectation
func (m *SqlTxMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlTxMock.Query with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SqlTxMock.Query")
		} else {
			m.t.Errorf("Expected call to SqlTxMock.Query with params: %#v", *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		m.t.Error("Expected call to SqlTxMock.Query")
	}
}

type mSqlTxMockRollback struct {
	mock               *SqlTxMock
	defaultExpectation *SqlTxMockRollbackExpectation
	expectations       []*SqlTxMockRollbackExpectation
}

// SqlTxMockRollbackExpectation specifies expectation struct of the sqlTx.Rollback
type SqlTxMockRollbackExpectation struct {
	mock *SqlTxMock

	results *SqlTxMockRollbackResults
	Counter uint64
}

// SqlTxMockRollbackResults contains results of the sqlTx.Rollback
type SqlTxMockRollbackResults struct {
	err error
}

// Expect sets up expected params for sqlTx.Rollback
func (m *mSqlTxMockRollback) Expect() *mSqlTxMockRollback {
	if m.mock.funcRollback != nil {
		m.mock.t.Fatalf("SqlTxMock.Rollback mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlTxMockRollbackExpectation{}
	}

	return m
}

// Return sets up results that will be returned by sqlTx.Rollback
func (m *mSqlTxMockRollback) Return(err error) *SqlTxMock {
	if m.mock.funcRollback != nil {
		m.mock.t.Fatalf("SqlTxMock.Rollback mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlTxMockRollbackExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &SqlTxMockRollbackResults{err}
	return m.mock
}

//Set uses given function f to mock the sqlTx.Rollback method
func (m *mSqlTxMockRollback) Set(f func() (err error)) *SqlTxMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the sqlTx.Rollback method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the sqlTx.Rollback method")
	}

	m.mock.funcRollback = f
	return m.mock
}

// Rollback implements sqlTx
func (m *SqlTxMock) Rollback() (err error) {
	mm_atomic.AddUint64(&m.beforeRollbackCounter, 1)
	defer mm_atomic.AddUint64(&m.afterRollbackCounter, 1)

	if m.RollbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.RollbackMock.defaultExpectation.Counter, 1)

		results := m.RollbackMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the SqlTxMock.Rollback")
		}
		return (*results).err
	}
	if m.funcRollback != nil {
		return m.funcRollback()
	}
	m.t.Fatalf("Unexpected call to SqlTxMock.Rollback.")
	return
}

// RollbackAfterCounter returns a count of finished SqlTxMock.Rollback invocations
func (m *SqlTxMock) RollbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterRollbackCounter)
}

// RollbackBeforeCounter returns a count of SqlTxMock.Rollback invocations
func (m *SqlTxMock) RollbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeRollbackCounter)
}

// MinimockRollbackDone returns true if the count of the Rollback invocations corresponds
// the number of defined expectations
func (m *SqlTxMock) MinimockRollbackDone() bool {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		return false
	}
	return true
}

// MinimockRollbackInspect logs each unmet expectation
func (m *SqlTxMock) MinimockRollbackInspect() {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SqlTxMock.Rollback")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		m.t.Error("Expected call to SqlTxMock.Rollback")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		m.t.Error("Expected call to SqlTxMock.Rollback")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SqlTxMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCommitInspect()

		m.MinimockExecInspect()

		m.MinimockPrepareInspect()

		m.MinimockQueryInspect()

		m.MinimockRollbackInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SqlTxMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SqlTxMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCommitDone() &&
		m.MinimockExecDone() &&
		m.MinimockPrepareDone() &&
		m.MinimockQueryDone() &&
		m.MinimockRollbackDone()
}
