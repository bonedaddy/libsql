package libsql

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"database/sql"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// SqlDBMock implements sqlDB
type SqlDBMock struct {
	t minimock.Tester

	funcBegin          func(ctx context.Context) (s1 sqlTx, err error)
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mSqlDBMockBegin

	funcClose          func() (err error)
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mSqlDBMockClose

	funcExec          func(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error)
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mSqlDBMockExec

	funcPrepare          func(ctx context.Context, query string) (s1 sqlStmt, err error)
	afterPrepareCounter  uint64
	beforePrepareCounter uint64
	PrepareMock          mSqlDBMockPrepare

	funcQuery          func(ctx context.Context, query string, args ...interface{}) (s1 sqlRows, err error)
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mSqlDBMockQuery
}

// NewSqlDBMock returns a mock for sqlDB
func NewSqlDBMock(t minimock.Tester) *SqlDBMock {
	m := &SqlDBMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}
	m.BeginMock = mSqlDBMockBegin{mock: m}
	m.CloseMock = mSqlDBMockClose{mock: m}
	m.ExecMock = mSqlDBMockExec{mock: m}
	m.PrepareMock = mSqlDBMockPrepare{mock: m}
	m.QueryMock = mSqlDBMockQuery{mock: m}

	return m
}

type mSqlDBMockBegin struct {
	mock               *SqlDBMock
	defaultExpectation *SqlDBMockBeginExpectation
	expectations       []*SqlDBMockBeginExpectation
}

// SqlDBMockBeginExpectation specifies expectation struct of the sqlDB.Begin
type SqlDBMockBeginExpectation struct {
	mock    *SqlDBMock
	params  *SqlDBMockBeginParams
	results *SqlDBMockBeginResults
	Counter uint64
}

// SqlDBMockBeginParams contains parameters of the sqlDB.Begin
type SqlDBMockBeginParams struct {
	ctx context.Context
}

// SqlDBMockBeginResults contains results of the sqlDB.Begin
type SqlDBMockBeginResults struct {
	s1  sqlTx
	err error
}

// Expect sets up expected params for sqlDB.Begin
func (m *mSqlDBMockBegin) Expect(ctx context.Context) *mSqlDBMockBegin {
	if m.mock.funcBegin != nil {
		m.mock.t.Fatalf("SqlDBMock.Begin mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlDBMockBeginExpectation{}
	}

	m.defaultExpectation.params = &SqlDBMockBeginParams{ctx}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by sqlDB.Begin
func (m *mSqlDBMockBegin) Return(s1 sqlTx, err error) *SqlDBMock {
	if m.mock.funcBegin != nil {
		m.mock.t.Fatalf("SqlDBMock.Begin mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlDBMockBeginExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &SqlDBMockBeginResults{s1, err}
	return m.mock
}

//Set uses given function f to mock the sqlDB.Begin method
func (m *mSqlDBMockBegin) Set(f func(ctx context.Context) (s1 sqlTx, err error)) *SqlDBMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the sqlDB.Begin method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the sqlDB.Begin method")
	}

	m.mock.funcBegin = f
	return m.mock
}

// When sets expectation for the sqlDB.Begin which will trigger the result defined by the following
// Then helper
func (m *mSqlDBMockBegin) When(ctx context.Context) *SqlDBMockBeginExpectation {
	if m.mock.funcBegin != nil {
		m.mock.t.Fatalf("SqlDBMock.Begin mock is already set by Set")
	}

	expectation := &SqlDBMockBeginExpectation{
		mock:   m.mock,
		params: &SqlDBMockBeginParams{ctx},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up sqlDB.Begin return parameters for the expectation previously defined by the When method
func (e *SqlDBMockBeginExpectation) Then(s1 sqlTx, err error) *SqlDBMock {
	e.results = &SqlDBMockBeginResults{s1, err}
	return e.mock
}

// Begin implements sqlDB
func (m *SqlDBMock) Begin(ctx context.Context) (s1 sqlTx, err error) {
	mm_atomic.AddUint64(&m.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&m.afterBeginCounter, 1)

	for _, e := range m.BeginMock.expectations {
		if minimock.Equal(*e.params, SqlDBMockBeginParams{ctx}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if m.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.BeginMock.defaultExpectation.Counter, 1)
		want := m.BeginMock.defaultExpectation.params
		got := SqlDBMockBeginParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("SqlDBMock.Begin got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.BeginMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the SqlDBMock.Begin")
		}
		return (*results).s1, (*results).err
	}
	if m.funcBegin != nil {
		return m.funcBegin(ctx)
	}
	m.t.Fatalf("Unexpected call to SqlDBMock.Begin. %v", ctx)
	return
}

// BeginAfterCounter returns a count of finished SqlDBMock.Begin invocations
func (m *SqlDBMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterBeginCounter)
}

// BeginBeforeCounter returns a count of SqlDBMock.Begin invocations
func (m *SqlDBMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeBeginCounter)
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *SqlDBMock) MinimockBeginDone() bool {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginInspect logs each unmet expectation
func (m *SqlDBMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlDBMock.Begin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		if m.BeginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SqlDBMock.Begin")
		} else {
			m.t.Errorf("Expected call to SqlDBMock.Begin with params: %#v", *m.BeginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		m.t.Error("Expected call to SqlDBMock.Begin")
	}
}

type mSqlDBMockClose struct {
	mock               *SqlDBMock
	defaultExpectation *SqlDBMockCloseExpectation
	expectations       []*SqlDBMockCloseExpectation
}

// SqlDBMockCloseExpectation specifies expectation struct of the sqlDB.Close
type SqlDBMockCloseExpectation struct {
	mock *SqlDBMock

	results *SqlDBMockCloseResults
	Counter uint64
}

// SqlDBMockCloseResults contains results of the sqlDB.Close
type SqlDBMockCloseResults struct {
	err error
}

// Expect sets up expected params for sqlDB.Close
func (m *mSqlDBMockClose) Expect() *mSqlDBMockClose {
	if m.mock.funcClose != nil {
		m.mock.t.Fatalf("SqlDBMock.Close mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlDBMockCloseExpectation{}
	}

	return m
}

// Return sets up results that will be returned by sqlDB.Close
func (m *mSqlDBMockClose) Return(err error) *SqlDBMock {
	if m.mock.funcClose != nil {
		m.mock.t.Fatalf("SqlDBMock.Close mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlDBMockCloseExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &SqlDBMockCloseResults{err}
	return m.mock
}

//Set uses given function f to mock the sqlDB.Close method
func (m *mSqlDBMockClose) Set(f func() (err error)) *SqlDBMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the sqlDB.Close method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the sqlDB.Close method")
	}

	m.mock.funcClose = f
	return m.mock
}

// Close implements sqlDB
func (m *SqlDBMock) Close() (err error) {
	mm_atomic.AddUint64(&m.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&m.afterCloseCounter, 1)

	if m.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.CloseMock.defaultExpectation.Counter, 1)

		results := m.CloseMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the SqlDBMock.Close")
		}
		return (*results).err
	}
	if m.funcClose != nil {
		return m.funcClose()
	}
	m.t.Fatalf("Unexpected call to SqlDBMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished SqlDBMock.Close invocations
func (m *SqlDBMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterCloseCounter)
}

// CloseBeforeCounter returns a count of SqlDBMock.Close invocations
func (m *SqlDBMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *SqlDBMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *SqlDBMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SqlDBMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to SqlDBMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to SqlDBMock.Close")
	}
}

type mSqlDBMockExec struct {
	mock               *SqlDBMock
	defaultExpectation *SqlDBMockExecExpectation
	expectations       []*SqlDBMockExecExpectation
}

// SqlDBMockExecExpectation specifies expectation struct of the sqlDB.Exec
type SqlDBMockExecExpectation struct {
	mock    *SqlDBMock
	params  *SqlDBMockExecParams
	results *SqlDBMockExecResults
	Counter uint64
}

// SqlDBMockExecParams contains parameters of the sqlDB.Exec
type SqlDBMockExecParams struct {
	ctx   context.Context
	query string
	args  []interface{}
}

// SqlDBMockExecResults contains results of the sqlDB.Exec
type SqlDBMockExecResults struct {
	r1  sql.Result
	err error
}

// Expect sets up expected params for sqlDB.Exec
func (m *mSqlDBMockExec) Expect(ctx context.Context, query string, args ...interface{}) *mSqlDBMockExec {
	if m.mock.funcExec != nil {
		m.mock.t.Fatalf("SqlDBMock.Exec mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlDBMockExecExpectation{}
	}

	m.defaultExpectation.params = &SqlDBMockExecParams{ctx, query, args}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by sqlDB.Exec
func (m *mSqlDBMockExec) Return(r1 sql.Result, err error) *SqlDBMock {
	if m.mock.funcExec != nil {
		m.mock.t.Fatalf("SqlDBMock.Exec mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlDBMockExecExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &SqlDBMockExecResults{r1, err}
	return m.mock
}

//Set uses given function f to mock the sqlDB.Exec method
func (m *mSqlDBMockExec) Set(f func(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error)) *SqlDBMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the sqlDB.Exec method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the sqlDB.Exec method")
	}

	m.mock.funcExec = f
	return m.mock
}

// When sets expectation for the sqlDB.Exec which will trigger the result defined by the following
// Then helper
func (m *mSqlDBMockExec) When(ctx context.Context, query string, args ...interface{}) *SqlDBMockExecExpectation {
	if m.mock.funcExec != nil {
		m.mock.t.Fatalf("SqlDBMock.Exec mock is already set by Set")
	}

	expectation := &SqlDBMockExecExpectation{
		mock:   m.mock,
		params: &SqlDBMockExecParams{ctx, query, args},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up sqlDB.Exec return parameters for the expectation previously defined by the When method
func (e *SqlDBMockExecExpectation) Then(r1 sql.Result, err error) *SqlDBMock {
	e.results = &SqlDBMockExecResults{r1, err}
	return e.mock
}

// Exec implements sqlDB
func (m *SqlDBMock) Exec(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error) {
	mm_atomic.AddUint64(&m.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&m.afterExecCounter, 1)

	for _, e := range m.ExecMock.expectations {
		if minimock.Equal(*e.params, SqlDBMockExecParams{ctx, query, args}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if m.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.ExecMock.defaultExpectation.Counter, 1)
		want := m.ExecMock.defaultExpectation.params
		got := SqlDBMockExecParams{ctx, query, args}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("SqlDBMock.Exec got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.ExecMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the SqlDBMock.Exec")
		}
		return (*results).r1, (*results).err
	}
	if m.funcExec != nil {
		return m.funcExec(ctx, query, args...)
	}
	m.t.Fatalf("Unexpected call to SqlDBMock.Exec. %v %v %v", ctx, query, args)
	return
}

// ExecAfterCounter returns a count of finished SqlDBMock.Exec invocations
func (m *SqlDBMock) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterExecCounter)
}

// ExecBeforeCounter returns a count of SqlDBMock.Exec invocations
func (m *SqlDBMock) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeExecCounter)
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *SqlDBMock) MinimockExecDone() bool {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	return true
}

// MinimockExecInspect logs each unmet expectation
func (m *SqlDBMock) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlDBMock.Exec with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SqlDBMock.Exec")
		} else {
			m.t.Errorf("Expected call to SqlDBMock.Exec with params: %#v", *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		m.t.Error("Expected call to SqlDBMock.Exec")
	}
}

type mSqlDBMockPrepare struct {
	mock               *SqlDBMock
	defaultExpectation *SqlDBMockPrepareExpectation
	expectations       []*SqlDBMockPrepareExpectation
}

// SqlDBMockPrepareExpectation specifies expectation struct of the sqlDB.Prepare
type SqlDBMockPrepareExpectation struct {
	mock    *SqlDBMock
	params  *SqlDBMockPrepareParams
	results *SqlDBMockPrepareResults
	Counter uint64
}

// SqlDBMockPrepareParams contains parameters of the sqlDB.Prepare
type SqlDBMockPrepareParams struct {
	ctx   context.Context
	query string
}

// SqlDBMockPrepareResults contains results of the sqlDB.Prepare
type SqlDBMockPrepareResults struct {
	s1  sqlStmt
	err error
}

// Expect sets up expected params for sqlDB.Prepare
func (m *mSqlDBMockPrepare) Expect(ctx context.Context, query string) *mSqlDBMockPrepare {
	if m.mock.funcPrepare != nil {
		m.mock.t.Fatalf("SqlDBMock.Prepare mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlDBMockPrepareExpectation{}
	}

	m.defaultExpectation.params = &SqlDBMockPrepareParams{ctx, query}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by sqlDB.Prepare
func (m *mSqlDBMockPrepare) Return(s1 sqlStmt, err error) *SqlDBMock {
	if m.mock.funcPrepare != nil {
		m.mock.t.Fatalf("SqlDBMock.Prepare mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlDBMockPrepareExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &SqlDBMockPrepareResults{s1, err}
	return m.mock
}

//Set uses given function f to mock the sqlDB.Prepare method
func (m *mSqlDBMockPrepare) Set(f func(ctx context.Context, query string) (s1 sqlStmt, err error)) *SqlDBMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the sqlDB.Prepare method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the sqlDB.Prepare method")
	}

	m.mock.funcPrepare = f
	return m.mock
}

// When sets expectation for the sqlDB.Prepare which will trigger the result defined by the following
// Then helper
func (m *mSqlDBMockPrepare) When(ctx context.Context, query string) *SqlDBMockPrepareExpectation {
	if m.mock.funcPrepare != nil {
		m.mock.t.Fatalf("SqlDBMock.Prepare mock is already set by Set")
	}

	expectation := &SqlDBMockPrepareExpectation{
		mock:   m.mock,
		params: &SqlDBMockPrepareParams{ctx, query},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up sqlDB.Prepare return parameters for the expectation previously defined by the When method
func (e *SqlDBMockPrepareExpectation) Then(s1 sqlStmt, err error) *SqlDBMock {
	e.results = &SqlDBMockPrepareResults{s1, err}
	return e.mock
}

// Prepare implements sqlDB
func (m *SqlDBMock) Prepare(ctx context.Context, query string) (s1 sqlStmt, err error) {
	mm_atomic.AddUint64(&m.beforePrepareCounter, 1)
	defer mm_atomic.AddUint64(&m.afterPrepareCounter, 1)

	for _, e := range m.PrepareMock.expectations {
		if minimock.Equal(*e.params, SqlDBMockPrepareParams{ctx, query}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if m.PrepareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.PrepareMock.defaultExpectation.Counter, 1)
		want := m.PrepareMock.defaultExpectation.params
		got := SqlDBMockPrepareParams{ctx, query}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("SqlDBMock.Prepare got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.PrepareMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the SqlDBMock.Prepare")
		}
		return (*results).s1, (*results).err
	}
	if m.funcPrepare != nil {
		return m.funcPrepare(ctx, query)
	}
	m.t.Fatalf("Unexpected call to SqlDBMock.Prepare. %v %v", ctx, query)
	return
}

// PrepareAfterCounter returns a count of finished SqlDBMock.Prepare invocations
func (m *SqlDBMock) PrepareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterPrepareCounter)
}

// PrepareBeforeCounter returns a count of SqlDBMock.Prepare invocations
func (m *SqlDBMock) PrepareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforePrepareCounter)
}

// MinimockPrepareDone returns true if the count of the Prepare invocations corresponds
// the number of defined expectations
func (m *SqlDBMock) MinimockPrepareDone() bool {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrepareInspect logs each unmet expectation
func (m *SqlDBMock) MinimockPrepareInspect() {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlDBMock.Prepare with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		if m.PrepareMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SqlDBMock.Prepare")
		} else {
			m.t.Errorf("Expected call to SqlDBMock.Prepare with params: %#v", *m.PrepareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		m.t.Error("Expected call to SqlDBMock.Prepare")
	}
}

type mSqlDBMockQuery struct {
	mock               *SqlDBMock
	defaultExpectation *SqlDBMockQueryExpectation
	expectations       []*SqlDBMockQueryExpectation
}

// SqlDBMockQueryExpectation specifies expectation struct of the sqlDB.Query
type SqlDBMockQueryExpectation struct {
	mock    *SqlDBMock
	params  *SqlDBMockQueryParams
	results *SqlDBMockQueryResults
	Counter uint64
}

// SqlDBMockQueryParams contains parameters of the sqlDB.Query
type SqlDBMockQueryParams struct {
	ctx   context.Context
	query string
	args  []interface{}
}

// SqlDBMockQueryResults contains results of the sqlDB.Query
type SqlDBMockQueryResults struct {
	s1  sqlRows
	err error
}

// Expect sets up expected params for sqlDB.Query
func (m *mSqlDBMockQuery) Expect(ctx context.Context, query string, args ...interface{}) *mSqlDBMockQuery {
	if m.mock.funcQuery != nil {
		m.mock.t.Fatalf("SqlDBMock.Query mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlDBMockQueryExpectation{}
	}

	m.defaultExpectation.params = &SqlDBMockQueryParams{ctx, query, args}
	for _, e := range m.expectations {
		if minimock.Equal(e.params, m.defaultExpectation.params) {
			m.mock.t.Fatalf("Expectation set by When has same params: %#v", *m.defaultExpectation.params)
		}
	}

	return m
}

// Return sets up results that will be returned by sqlDB.Query
func (m *mSqlDBMockQuery) Return(s1 sqlRows, err error) *SqlDBMock {
	if m.mock.funcQuery != nil {
		m.mock.t.Fatalf("SqlDBMock.Query mock is already set by Set")
	}

	if m.defaultExpectation == nil {
		m.defaultExpectation = &SqlDBMockQueryExpectation{mock: m.mock}
	}
	m.defaultExpectation.results = &SqlDBMockQueryResults{s1, err}
	return m.mock
}

//Set uses given function f to mock the sqlDB.Query method
func (m *mSqlDBMockQuery) Set(f func(ctx context.Context, query string, args ...interface{}) (s1 sqlRows, err error)) *SqlDBMock {
	if m.defaultExpectation != nil {
		m.mock.t.Fatalf("Default expectation is already set for the sqlDB.Query method")
	}

	if len(m.expectations) > 0 {
		m.mock.t.Fatalf("Some expectations are already set for the sqlDB.Query method")
	}

	m.mock.funcQuery = f
	return m.mock
}

// When sets expectation for the sqlDB.Query which will trigger the result defined by the following
// Then helper
func (m *mSqlDBMockQuery) When(ctx context.Context, query string, args ...interface{}) *SqlDBMockQueryExpectation {
	if m.mock.funcQuery != nil {
		m.mock.t.Fatalf("SqlDBMock.Query mock is already set by Set")
	}

	expectation := &SqlDBMockQueryExpectation{
		mock:   m.mock,
		params: &SqlDBMockQueryParams{ctx, query, args},
	}
	m.expectations = append(m.expectations, expectation)
	return expectation
}

// Then sets up sqlDB.Query return parameters for the expectation previously defined by the When method
func (e *SqlDBMockQueryExpectation) Then(s1 sqlRows, err error) *SqlDBMock {
	e.results = &SqlDBMockQueryResults{s1, err}
	return e.mock
}

// Query implements sqlDB
func (m *SqlDBMock) Query(ctx context.Context, query string, args ...interface{}) (s1 sqlRows, err error) {
	mm_atomic.AddUint64(&m.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&m.afterQueryCounter, 1)

	for _, e := range m.QueryMock.expectations {
		if minimock.Equal(*e.params, SqlDBMockQueryParams{ctx, query, args}) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if m.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&m.QueryMock.defaultExpectation.Counter, 1)
		want := m.QueryMock.defaultExpectation.params
		got := SqlDBMockQueryParams{ctx, query, args}
		if want != nil && !minimock.Equal(*want, got) {
			m.t.Errorf("SqlDBMock.Query got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := m.QueryMock.defaultExpectation.results
		if results == nil {
			m.t.Fatal("No results are set for the SqlDBMock.Query")
		}
		return (*results).s1, (*results).err
	}
	if m.funcQuery != nil {
		return m.funcQuery(ctx, query, args...)
	}
	m.t.Fatalf("Unexpected call to SqlDBMock.Query. %v %v %v", ctx, query, args)
	return
}

// QueryAfterCounter returns a count of finished SqlDBMock.Query invocations
func (m *SqlDBMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&m.afterQueryCounter)
}

// QueryBeforeCounter returns a count of SqlDBMock.Query invocations
func (m *SqlDBMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&m.beforeQueryCounter)
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *SqlDBMock) MinimockQueryDone() bool {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryInspect logs each unmet expectation
func (m *SqlDBMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlDBMock.Query with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SqlDBMock.Query")
		} else {
			m.t.Errorf("Expected call to SqlDBMock.Query with params: %#v", *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		m.t.Error("Expected call to SqlDBMock.Query")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SqlDBMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBeginInspect()

		m.MinimockCloseInspect()

		m.MinimockExecInspect()

		m.MinimockPrepareInspect()

		m.MinimockQueryInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SqlDBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SqlDBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockCloseDone() &&
		m.MinimockExecDone() &&
		m.MinimockPrepareDone() &&
		m.MinimockQueryDone()
}
