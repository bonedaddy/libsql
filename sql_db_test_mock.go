package libsql

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"database/sql"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SqlDBMock implements sqlDB
type SqlDBMock struct {
	t minimock.Tester

	funcBegin          func(ctx context.Context) (s1 sqlTx, err error)
	inspectFuncBegin   func(ctx context.Context)
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mSqlDBMockBegin

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mSqlDBMockClose

	funcExec          func(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error)
	inspectFuncExec   func(ctx context.Context, query string, args ...interface{})
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mSqlDBMockExec

	funcPrepare          func(ctx context.Context, query string) (s1 sqlStmt, err error)
	inspectFuncPrepare   func(ctx context.Context, query string)
	afterPrepareCounter  uint64
	beforePrepareCounter uint64
	PrepareMock          mSqlDBMockPrepare

	funcQuery          func(ctx context.Context, query string, args ...interface{}) (s1 sqlRows, err error)
	inspectFuncQuery   func(ctx context.Context, query string, args ...interface{})
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mSqlDBMockQuery
}

// NewSqlDBMock returns a mock for sqlDB
func NewSqlDBMock(t minimock.Tester) *SqlDBMock {
	m := &SqlDBMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginMock = mSqlDBMockBegin{mock: m}
	m.BeginMock.callArgs = []*SqlDBMockBeginParams{}

	m.CloseMock = mSqlDBMockClose{mock: m}

	m.ExecMock = mSqlDBMockExec{mock: m}
	m.ExecMock.callArgs = []*SqlDBMockExecParams{}

	m.PrepareMock = mSqlDBMockPrepare{mock: m}
	m.PrepareMock.callArgs = []*SqlDBMockPrepareParams{}

	m.QueryMock = mSqlDBMockQuery{mock: m}
	m.QueryMock.callArgs = []*SqlDBMockQueryParams{}

	return m
}

type mSqlDBMockBegin struct {
	mock               *SqlDBMock
	defaultExpectation *SqlDBMockBeginExpectation
	expectations       []*SqlDBMockBeginExpectation

	callArgs []*SqlDBMockBeginParams
	mutex    sync.RWMutex
}

// SqlDBMockBeginExpectation specifies expectation struct of the sqlDB.Begin
type SqlDBMockBeginExpectation struct {
	mock    *SqlDBMock
	params  *SqlDBMockBeginParams
	results *SqlDBMockBeginResults
	Counter uint64
}

// SqlDBMockBeginParams contains parameters of the sqlDB.Begin
type SqlDBMockBeginParams struct {
	ctx context.Context
}

// SqlDBMockBeginResults contains results of the sqlDB.Begin
type SqlDBMockBeginResults struct {
	s1  sqlTx
	err error
}

// Expect sets up expected params for sqlDB.Begin
func (mmBegin *mSqlDBMockBegin) Expect(ctx context.Context) *mSqlDBMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("SqlDBMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &SqlDBMockBeginExpectation{}
	}

	mmBegin.defaultExpectation.params = &SqlDBMockBeginParams{ctx}
	for _, e := range mmBegin.expectations {
		if minimock.Equal(e.params, mmBegin.defaultExpectation.params) {
			mmBegin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBegin.defaultExpectation.params)
		}
	}

	return mmBegin
}

// Inspect accepts an inspector function that has same arguments as the sqlDB.Begin
func (mmBegin *mSqlDBMockBegin) Inspect(f func(ctx context.Context)) *mSqlDBMockBegin {
	if mmBegin.mock.inspectFuncBegin != nil {
		mmBegin.mock.t.Fatalf("Inspect function is already set for SqlDBMock.Begin")
	}

	mmBegin.mock.inspectFuncBegin = f

	return mmBegin
}

// Return sets up results that will be returned by sqlDB.Begin
func (mmBegin *mSqlDBMockBegin) Return(s1 sqlTx, err error) *SqlDBMock {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("SqlDBMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &SqlDBMockBeginExpectation{mock: mmBegin.mock}
	}
	mmBegin.defaultExpectation.results = &SqlDBMockBeginResults{s1, err}
	return mmBegin.mock
}

//Set uses given function f to mock the sqlDB.Begin method
func (mmBegin *mSqlDBMockBegin) Set(f func(ctx context.Context) (s1 sqlTx, err error)) *SqlDBMock {
	if mmBegin.defaultExpectation != nil {
		mmBegin.mock.t.Fatalf("Default expectation is already set for the sqlDB.Begin method")
	}

	if len(mmBegin.expectations) > 0 {
		mmBegin.mock.t.Fatalf("Some expectations are already set for the sqlDB.Begin method")
	}

	mmBegin.mock.funcBegin = f
	return mmBegin.mock
}

// When sets expectation for the sqlDB.Begin which will trigger the result defined by the following
// Then helper
func (mmBegin *mSqlDBMockBegin) When(ctx context.Context) *SqlDBMockBeginExpectation {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("SqlDBMock.Begin mock is already set by Set")
	}

	expectation := &SqlDBMockBeginExpectation{
		mock:   mmBegin.mock,
		params: &SqlDBMockBeginParams{ctx},
	}
	mmBegin.expectations = append(mmBegin.expectations, expectation)
	return expectation
}

// Then sets up sqlDB.Begin return parameters for the expectation previously defined by the When method
func (e *SqlDBMockBeginExpectation) Then(s1 sqlTx, err error) *SqlDBMock {
	e.results = &SqlDBMockBeginResults{s1, err}
	return e.mock
}

// Begin implements sqlDB
func (mmBegin *SqlDBMock) Begin(ctx context.Context) (s1 sqlTx, err error) {
	mm_atomic.AddUint64(&mmBegin.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmBegin.afterBeginCounter, 1)

	if mmBegin.inspectFuncBegin != nil {
		mmBegin.inspectFuncBegin(ctx)
	}

	mm_params := &SqlDBMockBeginParams{ctx}

	// Record call args
	mmBegin.BeginMock.mutex.Lock()
	mmBegin.BeginMock.callArgs = append(mmBegin.BeginMock.callArgs, mm_params)
	mmBegin.BeginMock.mutex.Unlock()

	for _, e := range mmBegin.BeginMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmBegin.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBegin.BeginMock.defaultExpectation.Counter, 1)
		mm_want := mmBegin.BeginMock.defaultExpectation.params
		mm_got := SqlDBMockBeginParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBegin.t.Errorf("SqlDBMock.Begin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBegin.BeginMock.defaultExpectation.results
		if mm_results == nil {
			mmBegin.t.Fatal("No results are set for the SqlDBMock.Begin")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmBegin.funcBegin != nil {
		return mmBegin.funcBegin(ctx)
	}
	mmBegin.t.Fatalf("Unexpected call to SqlDBMock.Begin. %v", ctx)
	return
}

// BeginAfterCounter returns a count of finished SqlDBMock.Begin invocations
func (mmBegin *SqlDBMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.afterBeginCounter)
}

// BeginBeforeCounter returns a count of SqlDBMock.Begin invocations
func (mmBegin *SqlDBMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.beforeBeginCounter)
}

// Calls returns a list of arguments used in each call to SqlDBMock.Begin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBegin *mSqlDBMockBegin) Calls() []*SqlDBMockBeginParams {
	mmBegin.mutex.RLock()

	argCopy := make([]*SqlDBMockBeginParams, len(mmBegin.callArgs))
	copy(argCopy, mmBegin.callArgs)

	mmBegin.mutex.RUnlock()

	return argCopy
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *SqlDBMock) MinimockBeginDone() bool {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginInspect logs each unmet expectation
func (m *SqlDBMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlDBMock.Begin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		if m.BeginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SqlDBMock.Begin")
		} else {
			m.t.Errorf("Expected call to SqlDBMock.Begin with params: %#v", *m.BeginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		m.t.Error("Expected call to SqlDBMock.Begin")
	}
}

type mSqlDBMockClose struct {
	mock               *SqlDBMock
	defaultExpectation *SqlDBMockCloseExpectation
	expectations       []*SqlDBMockCloseExpectation
}

// SqlDBMockCloseExpectation specifies expectation struct of the sqlDB.Close
type SqlDBMockCloseExpectation struct {
	mock *SqlDBMock

	results *SqlDBMockCloseResults
	Counter uint64
}

// SqlDBMockCloseResults contains results of the sqlDB.Close
type SqlDBMockCloseResults struct {
	err error
}

// Expect sets up expected params for sqlDB.Close
func (mmClose *mSqlDBMockClose) Expect() *mSqlDBMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("SqlDBMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &SqlDBMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the sqlDB.Close
func (mmClose *mSqlDBMockClose) Inspect(f func()) *mSqlDBMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for SqlDBMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by sqlDB.Close
func (mmClose *mSqlDBMockClose) Return(err error) *SqlDBMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("SqlDBMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &SqlDBMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &SqlDBMockCloseResults{err}
	return mmClose.mock
}

//Set uses given function f to mock the sqlDB.Close method
func (mmClose *mSqlDBMockClose) Set(f func() (err error)) *SqlDBMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the sqlDB.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the sqlDB.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements sqlDB
func (mmClose *SqlDBMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the SqlDBMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to SqlDBMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished SqlDBMock.Close invocations
func (mmClose *SqlDBMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of SqlDBMock.Close invocations
func (mmClose *SqlDBMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *SqlDBMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *SqlDBMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to SqlDBMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to SqlDBMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to SqlDBMock.Close")
	}
}

type mSqlDBMockExec struct {
	mock               *SqlDBMock
	defaultExpectation *SqlDBMockExecExpectation
	expectations       []*SqlDBMockExecExpectation

	callArgs []*SqlDBMockExecParams
	mutex    sync.RWMutex
}

// SqlDBMockExecExpectation specifies expectation struct of the sqlDB.Exec
type SqlDBMockExecExpectation struct {
	mock    *SqlDBMock
	params  *SqlDBMockExecParams
	results *SqlDBMockExecResults
	Counter uint64
}

// SqlDBMockExecParams contains parameters of the sqlDB.Exec
type SqlDBMockExecParams struct {
	ctx   context.Context
	query string
	args  []interface{}
}

// SqlDBMockExecResults contains results of the sqlDB.Exec
type SqlDBMockExecResults struct {
	r1  sql.Result
	err error
}

// Expect sets up expected params for sqlDB.Exec
func (mmExec *mSqlDBMockExec) Expect(ctx context.Context, query string, args ...interface{}) *mSqlDBMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("SqlDBMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &SqlDBMockExecExpectation{}
	}

	mmExec.defaultExpectation.params = &SqlDBMockExecParams{ctx, query, args}
	for _, e := range mmExec.expectations {
		if minimock.Equal(e.params, mmExec.defaultExpectation.params) {
			mmExec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExec.defaultExpectation.params)
		}
	}

	return mmExec
}

// Inspect accepts an inspector function that has same arguments as the sqlDB.Exec
func (mmExec *mSqlDBMockExec) Inspect(f func(ctx context.Context, query string, args ...interface{})) *mSqlDBMockExec {
	if mmExec.mock.inspectFuncExec != nil {
		mmExec.mock.t.Fatalf("Inspect function is already set for SqlDBMock.Exec")
	}

	mmExec.mock.inspectFuncExec = f

	return mmExec
}

// Return sets up results that will be returned by sqlDB.Exec
func (mmExec *mSqlDBMockExec) Return(r1 sql.Result, err error) *SqlDBMock {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("SqlDBMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &SqlDBMockExecExpectation{mock: mmExec.mock}
	}
	mmExec.defaultExpectation.results = &SqlDBMockExecResults{r1, err}
	return mmExec.mock
}

//Set uses given function f to mock the sqlDB.Exec method
func (mmExec *mSqlDBMockExec) Set(f func(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error)) *SqlDBMock {
	if mmExec.defaultExpectation != nil {
		mmExec.mock.t.Fatalf("Default expectation is already set for the sqlDB.Exec method")
	}

	if len(mmExec.expectations) > 0 {
		mmExec.mock.t.Fatalf("Some expectations are already set for the sqlDB.Exec method")
	}

	mmExec.mock.funcExec = f
	return mmExec.mock
}

// When sets expectation for the sqlDB.Exec which will trigger the result defined by the following
// Then helper
func (mmExec *mSqlDBMockExec) When(ctx context.Context, query string, args ...interface{}) *SqlDBMockExecExpectation {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("SqlDBMock.Exec mock is already set by Set")
	}

	expectation := &SqlDBMockExecExpectation{
		mock:   mmExec.mock,
		params: &SqlDBMockExecParams{ctx, query, args},
	}
	mmExec.expectations = append(mmExec.expectations, expectation)
	return expectation
}

// Then sets up sqlDB.Exec return parameters for the expectation previously defined by the When method
func (e *SqlDBMockExecExpectation) Then(r1 sql.Result, err error) *SqlDBMock {
	e.results = &SqlDBMockExecResults{r1, err}
	return e.mock
}

// Exec implements sqlDB
func (mmExec *SqlDBMock) Exec(ctx context.Context, query string, args ...interface{}) (r1 sql.Result, err error) {
	mm_atomic.AddUint64(&mmExec.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&mmExec.afterExecCounter, 1)

	if mmExec.inspectFuncExec != nil {
		mmExec.inspectFuncExec(ctx, query, args...)
	}

	mm_params := &SqlDBMockExecParams{ctx, query, args}

	// Record call args
	mmExec.ExecMock.mutex.Lock()
	mmExec.ExecMock.callArgs = append(mmExec.ExecMock.callArgs, mm_params)
	mmExec.ExecMock.mutex.Unlock()

	for _, e := range mmExec.ExecMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmExec.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExec.ExecMock.defaultExpectation.Counter, 1)
		mm_want := mmExec.ExecMock.defaultExpectation.params
		mm_got := SqlDBMockExecParams{ctx, query, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExec.t.Errorf("SqlDBMock.Exec got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExec.ExecMock.defaultExpectation.results
		if mm_results == nil {
			mmExec.t.Fatal("No results are set for the SqlDBMock.Exec")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmExec.funcExec != nil {
		return mmExec.funcExec(ctx, query, args...)
	}
	mmExec.t.Fatalf("Unexpected call to SqlDBMock.Exec. %v %v %v", ctx, query, args)
	return
}

// ExecAfterCounter returns a count of finished SqlDBMock.Exec invocations
func (mmExec *SqlDBMock) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.afterExecCounter)
}

// ExecBeforeCounter returns a count of SqlDBMock.Exec invocations
func (mmExec *SqlDBMock) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.beforeExecCounter)
}

// Calls returns a list of arguments used in each call to SqlDBMock.Exec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExec *mSqlDBMockExec) Calls() []*SqlDBMockExecParams {
	mmExec.mutex.RLock()

	argCopy := make([]*SqlDBMockExecParams, len(mmExec.callArgs))
	copy(argCopy, mmExec.callArgs)

	mmExec.mutex.RUnlock()

	return argCopy
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *SqlDBMock) MinimockExecDone() bool {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	return true
}

// MinimockExecInspect logs each unmet expectation
func (m *SqlDBMock) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlDBMock.Exec with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SqlDBMock.Exec")
		} else {
			m.t.Errorf("Expected call to SqlDBMock.Exec with params: %#v", *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		m.t.Error("Expected call to SqlDBMock.Exec")
	}
}

type mSqlDBMockPrepare struct {
	mock               *SqlDBMock
	defaultExpectation *SqlDBMockPrepareExpectation
	expectations       []*SqlDBMockPrepareExpectation

	callArgs []*SqlDBMockPrepareParams
	mutex    sync.RWMutex
}

// SqlDBMockPrepareExpectation specifies expectation struct of the sqlDB.Prepare
type SqlDBMockPrepareExpectation struct {
	mock    *SqlDBMock
	params  *SqlDBMockPrepareParams
	results *SqlDBMockPrepareResults
	Counter uint64
}

// SqlDBMockPrepareParams contains parameters of the sqlDB.Prepare
type SqlDBMockPrepareParams struct {
	ctx   context.Context
	query string
}

// SqlDBMockPrepareResults contains results of the sqlDB.Prepare
type SqlDBMockPrepareResults struct {
	s1  sqlStmt
	err error
}

// Expect sets up expected params for sqlDB.Prepare
func (mmPrepare *mSqlDBMockPrepare) Expect(ctx context.Context, query string) *mSqlDBMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("SqlDBMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &SqlDBMockPrepareExpectation{}
	}

	mmPrepare.defaultExpectation.params = &SqlDBMockPrepareParams{ctx, query}
	for _, e := range mmPrepare.expectations {
		if minimock.Equal(e.params, mmPrepare.defaultExpectation.params) {
			mmPrepare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrepare.defaultExpectation.params)
		}
	}

	return mmPrepare
}

// Inspect accepts an inspector function that has same arguments as the sqlDB.Prepare
func (mmPrepare *mSqlDBMockPrepare) Inspect(f func(ctx context.Context, query string)) *mSqlDBMockPrepare {
	if mmPrepare.mock.inspectFuncPrepare != nil {
		mmPrepare.mock.t.Fatalf("Inspect function is already set for SqlDBMock.Prepare")
	}

	mmPrepare.mock.inspectFuncPrepare = f

	return mmPrepare
}

// Return sets up results that will be returned by sqlDB.Prepare
func (mmPrepare *mSqlDBMockPrepare) Return(s1 sqlStmt, err error) *SqlDBMock {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("SqlDBMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &SqlDBMockPrepareExpectation{mock: mmPrepare.mock}
	}
	mmPrepare.defaultExpectation.results = &SqlDBMockPrepareResults{s1, err}
	return mmPrepare.mock
}

//Set uses given function f to mock the sqlDB.Prepare method
func (mmPrepare *mSqlDBMockPrepare) Set(f func(ctx context.Context, query string) (s1 sqlStmt, err error)) *SqlDBMock {
	if mmPrepare.defaultExpectation != nil {
		mmPrepare.mock.t.Fatalf("Default expectation is already set for the sqlDB.Prepare method")
	}

	if len(mmPrepare.expectations) > 0 {
		mmPrepare.mock.t.Fatalf("Some expectations are already set for the sqlDB.Prepare method")
	}

	mmPrepare.mock.funcPrepare = f
	return mmPrepare.mock
}

// When sets expectation for the sqlDB.Prepare which will trigger the result defined by the following
// Then helper
func (mmPrepare *mSqlDBMockPrepare) When(ctx context.Context, query string) *SqlDBMockPrepareExpectation {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("SqlDBMock.Prepare mock is already set by Set")
	}

	expectation := &SqlDBMockPrepareExpectation{
		mock:   mmPrepare.mock,
		params: &SqlDBMockPrepareParams{ctx, query},
	}
	mmPrepare.expectations = append(mmPrepare.expectations, expectation)
	return expectation
}

// Then sets up sqlDB.Prepare return parameters for the expectation previously defined by the When method
func (e *SqlDBMockPrepareExpectation) Then(s1 sqlStmt, err error) *SqlDBMock {
	e.results = &SqlDBMockPrepareResults{s1, err}
	return e.mock
}

// Prepare implements sqlDB
func (mmPrepare *SqlDBMock) Prepare(ctx context.Context, query string) (s1 sqlStmt, err error) {
	mm_atomic.AddUint64(&mmPrepare.beforePrepareCounter, 1)
	defer mm_atomic.AddUint64(&mmPrepare.afterPrepareCounter, 1)

	if mmPrepare.inspectFuncPrepare != nil {
		mmPrepare.inspectFuncPrepare(ctx, query)
	}

	mm_params := &SqlDBMockPrepareParams{ctx, query}

	// Record call args
	mmPrepare.PrepareMock.mutex.Lock()
	mmPrepare.PrepareMock.callArgs = append(mmPrepare.PrepareMock.callArgs, mm_params)
	mmPrepare.PrepareMock.mutex.Unlock()

	for _, e := range mmPrepare.PrepareMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmPrepare.PrepareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrepare.PrepareMock.defaultExpectation.Counter, 1)
		mm_want := mmPrepare.PrepareMock.defaultExpectation.params
		mm_got := SqlDBMockPrepareParams{ctx, query}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrepare.t.Errorf("SqlDBMock.Prepare got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrepare.PrepareMock.defaultExpectation.results
		if mm_results == nil {
			mmPrepare.t.Fatal("No results are set for the SqlDBMock.Prepare")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmPrepare.funcPrepare != nil {
		return mmPrepare.funcPrepare(ctx, query)
	}
	mmPrepare.t.Fatalf("Unexpected call to SqlDBMock.Prepare. %v %v", ctx, query)
	return
}

// PrepareAfterCounter returns a count of finished SqlDBMock.Prepare invocations
func (mmPrepare *SqlDBMock) PrepareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.afterPrepareCounter)
}

// PrepareBeforeCounter returns a count of SqlDBMock.Prepare invocations
func (mmPrepare *SqlDBMock) PrepareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.beforePrepareCounter)
}

// Calls returns a list of arguments used in each call to SqlDBMock.Prepare.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrepare *mSqlDBMockPrepare) Calls() []*SqlDBMockPrepareParams {
	mmPrepare.mutex.RLock()

	argCopy := make([]*SqlDBMockPrepareParams, len(mmPrepare.callArgs))
	copy(argCopy, mmPrepare.callArgs)

	mmPrepare.mutex.RUnlock()

	return argCopy
}

// MinimockPrepareDone returns true if the count of the Prepare invocations corresponds
// the number of defined expectations
func (m *SqlDBMock) MinimockPrepareDone() bool {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrepareInspect logs each unmet expectation
func (m *SqlDBMock) MinimockPrepareInspect() {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlDBMock.Prepare with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		if m.PrepareMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SqlDBMock.Prepare")
		} else {
			m.t.Errorf("Expected call to SqlDBMock.Prepare with params: %#v", *m.PrepareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		m.t.Error("Expected call to SqlDBMock.Prepare")
	}
}

type mSqlDBMockQuery struct {
	mock               *SqlDBMock
	defaultExpectation *SqlDBMockQueryExpectation
	expectations       []*SqlDBMockQueryExpectation

	callArgs []*SqlDBMockQueryParams
	mutex    sync.RWMutex
}

// SqlDBMockQueryExpectation specifies expectation struct of the sqlDB.Query
type SqlDBMockQueryExpectation struct {
	mock    *SqlDBMock
	params  *SqlDBMockQueryParams
	results *SqlDBMockQueryResults
	Counter uint64
}

// SqlDBMockQueryParams contains parameters of the sqlDB.Query
type SqlDBMockQueryParams struct {
	ctx   context.Context
	query string
	args  []interface{}
}

// SqlDBMockQueryResults contains results of the sqlDB.Query
type SqlDBMockQueryResults struct {
	s1  sqlRows
	err error
}

// Expect sets up expected params for sqlDB.Query
func (mmQuery *mSqlDBMockQuery) Expect(ctx context.Context, query string, args ...interface{}) *mSqlDBMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("SqlDBMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &SqlDBMockQueryExpectation{}
	}

	mmQuery.defaultExpectation.params = &SqlDBMockQueryParams{ctx, query, args}
	for _, e := range mmQuery.expectations {
		if minimock.Equal(e.params, mmQuery.defaultExpectation.params) {
			mmQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuery.defaultExpectation.params)
		}
	}

	return mmQuery
}

// Inspect accepts an inspector function that has same arguments as the sqlDB.Query
func (mmQuery *mSqlDBMockQuery) Inspect(f func(ctx context.Context, query string, args ...interface{})) *mSqlDBMockQuery {
	if mmQuery.mock.inspectFuncQuery != nil {
		mmQuery.mock.t.Fatalf("Inspect function is already set for SqlDBMock.Query")
	}

	mmQuery.mock.inspectFuncQuery = f

	return mmQuery
}

// Return sets up results that will be returned by sqlDB.Query
func (mmQuery *mSqlDBMockQuery) Return(s1 sqlRows, err error) *SqlDBMock {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("SqlDBMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &SqlDBMockQueryExpectation{mock: mmQuery.mock}
	}
	mmQuery.defaultExpectation.results = &SqlDBMockQueryResults{s1, err}
	return mmQuery.mock
}

//Set uses given function f to mock the sqlDB.Query method
func (mmQuery *mSqlDBMockQuery) Set(f func(ctx context.Context, query string, args ...interface{}) (s1 sqlRows, err error)) *SqlDBMock {
	if mmQuery.defaultExpectation != nil {
		mmQuery.mock.t.Fatalf("Default expectation is already set for the sqlDB.Query method")
	}

	if len(mmQuery.expectations) > 0 {
		mmQuery.mock.t.Fatalf("Some expectations are already set for the sqlDB.Query method")
	}

	mmQuery.mock.funcQuery = f
	return mmQuery.mock
}

// When sets expectation for the sqlDB.Query which will trigger the result defined by the following
// Then helper
func (mmQuery *mSqlDBMockQuery) When(ctx context.Context, query string, args ...interface{}) *SqlDBMockQueryExpectation {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("SqlDBMock.Query mock is already set by Set")
	}

	expectation := &SqlDBMockQueryExpectation{
		mock:   mmQuery.mock,
		params: &SqlDBMockQueryParams{ctx, query, args},
	}
	mmQuery.expectations = append(mmQuery.expectations, expectation)
	return expectation
}

// Then sets up sqlDB.Query return parameters for the expectation previously defined by the When method
func (e *SqlDBMockQueryExpectation) Then(s1 sqlRows, err error) *SqlDBMock {
	e.results = &SqlDBMockQueryResults{s1, err}
	return e.mock
}

// Query implements sqlDB
func (mmQuery *SqlDBMock) Query(ctx context.Context, query string, args ...interface{}) (s1 sqlRows, err error) {
	mm_atomic.AddUint64(&mmQuery.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmQuery.afterQueryCounter, 1)

	if mmQuery.inspectFuncQuery != nil {
		mmQuery.inspectFuncQuery(ctx, query, args...)
	}

	mm_params := &SqlDBMockQueryParams{ctx, query, args}

	// Record call args
	mmQuery.QueryMock.mutex.Lock()
	mmQuery.QueryMock.callArgs = append(mmQuery.QueryMock.callArgs, mm_params)
	mmQuery.QueryMock.mutex.Unlock()

	for _, e := range mmQuery.QueryMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmQuery.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuery.QueryMock.defaultExpectation.Counter, 1)
		mm_want := mmQuery.QueryMock.defaultExpectation.params
		mm_got := SqlDBMockQueryParams{ctx, query, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuery.t.Errorf("SqlDBMock.Query got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuery.QueryMock.defaultExpectation.results
		if mm_results == nil {
			mmQuery.t.Fatal("No results are set for the SqlDBMock.Query")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmQuery.funcQuery != nil {
		return mmQuery.funcQuery(ctx, query, args...)
	}
	mmQuery.t.Fatalf("Unexpected call to SqlDBMock.Query. %v %v %v", ctx, query, args)
	return
}

// QueryAfterCounter returns a count of finished SqlDBMock.Query invocations
func (mmQuery *SqlDBMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.afterQueryCounter)
}

// QueryBeforeCounter returns a count of SqlDBMock.Query invocations
func (mmQuery *SqlDBMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.beforeQueryCounter)
}

// Calls returns a list of arguments used in each call to SqlDBMock.Query.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuery *mSqlDBMockQuery) Calls() []*SqlDBMockQueryParams {
	mmQuery.mutex.RLock()

	argCopy := make([]*SqlDBMockQueryParams, len(mmQuery.callArgs))
	copy(argCopy, mmQuery.callArgs)

	mmQuery.mutex.RUnlock()

	return argCopy
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *SqlDBMock) MinimockQueryDone() bool {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryInspect logs each unmet expectation
func (m *SqlDBMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SqlDBMock.Query with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SqlDBMock.Query")
		} else {
			m.t.Errorf("Expected call to SqlDBMock.Query with params: %#v", *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		m.t.Error("Expected call to SqlDBMock.Query")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SqlDBMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBeginInspect()

		m.MinimockCloseInspect()

		m.MinimockExecInspect()

		m.MinimockPrepareInspect()

		m.MinimockQueryInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SqlDBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SqlDBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockCloseDone() &&
		m.MinimockExecDone() &&
		m.MinimockPrepareDone() &&
		m.MinimockQueryDone()
}
